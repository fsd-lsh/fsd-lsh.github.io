{"meta":{"title":"Force's Blog","subtitle":"专注于全栈开发","description":"专注于全栈开发","author":"Force","url":"http://easybhu.cn","root":"/"},"pages":[{"title":"关于","date":"2020-02-02T07:25:32.000Z","updated":"2020-02-02T07:43:31.237Z","comments":true,"path":"about/index.html","permalink":"http://easybhu.cn/about/index.html","excerpt":"","text":"这个站点是记录我日常工作时碰到的问题及解决办法的集合地， 也是本人对技术热爱的精神领地！ 业余时间我会继续维护开源项目。 欢迎相关行业博主互链！"},{"title":"链接","date":"2020-02-02T07:26:14.000Z","updated":"2020-02-02T08:44:03.926Z","comments":true,"path":"links/index.html","permalink":"http://easybhu.cn/links/index.html","excerpt":"","text":"明月登楼学习笔记Blog阿宇技术博客"}],"posts":[{"title":"软件开发版本各阶段","slug":"软件开发版本各阶段","date":"2020-04-09T10:06:50.000Z","updated":"2020-04-09T10:07:04.861Z","comments":true,"path":"2020/04/09/软件开发版本各阶段/","link":"","permalink":"http://easybhu.cn/2020/04/09/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%89%88%E6%9C%AC%E5%90%84%E9%98%B6%E6%AE%B5/","excerpt":"","text":"软件版本周期 α、β、λ 常用来表示软件测试过程中的三个阶段。 -- α 是第一阶段，一般只供内部测试使用； --&nbsp;β是第二个阶段，已经消除了软件中大部分的不完善之处，但仍有可能还存在缺陷和漏洞，一般只提供给特定的用户群来测试使用； --&nbsp;λ是第三个阶段，此时产品已经相当成熟，只需在个别地方再做进一步的优化处理即可上市发行。 开发期 -- Alpha(α)：预览版，或者叫内部测试版；一般不向外部发布，会有很多Bug；一般只有测试人员使用。 -- Beta(β)：测试版，或者叫公开测试版；这个阶段的版本会一直加入新的功能；在 Alpha版之后推出。 -- RC(Release Candidate)：最终测试版本；可能成为最终产品的候选版本，如果未出现问题则可发布成为正式版本 多数开源软件会推出两个RC版本，最后的 RC2 则成为正式版本。 完成期 -- Stable：稳定版；来自预览版本释出使用与改善而修正完成。 -- GA(General Availability)：正式发布的版本；在国外都是用GA来说明release版本的。 -- RTM(Release to Manufacturing)：给生产商的release版本；RTM版本并不一定意味着创作者解决了软件所有问题；仍有可能向公众发布前更新版本。 另外一种RTM的称呼是RTW（Release To Web），表示正式版本的软件发布到Web网站上供客户免费下载。 -- RTL(Retail)：零售版；是真正的正式版，正式上架零售版。 以Windows 7为例，RTM版与零售版的版本号是一样的。 其他表述 -- OEM(Original Equipment Manufacturer)：原始设备制造商；是给计算机厂商随着计算机贩卖的，也就是随机版； 只能随机器出货，不能零售。只能全新安装，不能从旧有操作系统升级。包装不像零售版精美，通常只有一面CD和说明书(授权书)。 -- RVL：号称是正式版，其实RVL根本不是版本的名称。它是中文版/英文版文档破解出来的。 -- EVAL：而流通在网络上的EVAL版，与“评估版”类似，功能上和零售版没有区别。","categories":[{"name":"Version","slug":"Version","permalink":"http://easybhu.cn/categories/Version/"}],"tags":[{"name":"Version","slug":"Version","permalink":"http://easybhu.cn/tags/Version/"}]},{"title":"php 获取本周开始日期和结束日期的方法","slug":"php-获取本周开始日期和结束日期的方法","date":"2020-02-02T09:40:40.000Z","updated":"2020-02-02T09:42:16.718Z","comments":true,"path":"2020/02/02/php-获取本周开始日期和结束日期的方法/","link":"","permalink":"http://easybhu.cn/2020/02/02/php-%E8%8E%B7%E5%8F%96%E6%9C%AC%E5%91%A8%E5%BC%80%E5%A7%8B%E6%97%A5%E6%9C%9F%E5%92%8C%E7%BB%93%E6%9D%9F%E6%97%A5%E6%9C%9F%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"// 当前日期 $sdefaultDate = date(\"Y-m-d\"); // $first =1 表示每周星期一为开始日期 0表示每周日为开始日期 $first=1; // 获取当前周的第几天 周日是0 周一到周六是 1 - 6 $w = date('w', strtotime($sdefaultDate)); // 获取本周开始日期，如果$w是0，则表示周日，减去 6 天 $week_start=date('Y-m-d', strtotime(\"$sdefaultDate -\".($w ? $w - $first : 6).' days')); // 本周结束日期 $week_end=date('Y-m-d',strtotime(\"$week_start +6 days\")); echo \"$week_start\".\"$week_end\";","categories":[{"name":"Php","slug":"Php","permalink":"http://easybhu.cn/categories/Php/"}],"tags":[{"name":"Php","slug":"Php","permalink":"http://easybhu.cn/tags/Php/"}]},{"title":"MySQL查看数据库表容量大小","slug":"MySQL查看数据库表容量大小","date":"2020-02-02T09:38:27.000Z","updated":"2020-02-02T09:40:24.405Z","comments":true,"path":"2020/02/02/MySQL查看数据库表容量大小/","link":"","permalink":"http://easybhu.cn/2020/02/02/MySQL%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E5%AE%B9%E9%87%8F%E5%A4%A7%E5%B0%8F/","excerpt":"","text":"【https://blog.csdn.net/fdipzone/article/details/80144166】1.查看所有数据库容量大小12345678selecttable_schema&nbsp;as&nbsp;'数据库',sum(table_rows)&nbsp;as&nbsp;'记录数',sum(truncate(data_length/1024/1024, 2))&nbsp;as&nbsp;'数据容量(MB)',sum(truncate(index_length/1024/1024, 2))&nbsp;as&nbsp;'索引容量(MB)'from&nbsp;information_schema.tablesgroup&nbsp;by&nbsp;table_schemaorder&nbsp;by&nbsp;sum(data_length) desc, sum(index_length) desc; 2.查看所有数据库各表容量大小12345678selecttable_schema&nbsp;as&nbsp;'数据库',table_name&nbsp;as&nbsp;'表名',table_rows&nbsp;as&nbsp;'记录数',truncate(data_length/1024/1024, 2)&nbsp;as&nbsp;'数据容量(MB)',truncate(index_length/1024/1024, 2)&nbsp;as&nbsp;'索引容量(MB)'from&nbsp;information_schema.tablesorder&nbsp;by&nbsp;data_length desc, index_length desc; 3.查看指定数据库容量大小例：查看mysql库容量大小1234567selecttable_schema&nbsp;as&nbsp;'数据库',sum(table_rows)&nbsp;as&nbsp;'记录数',sum(truncate(data_length/1024/1024, 2))&nbsp;as&nbsp;'数据容量(MB)',sum(truncate(index_length/1024/1024, 2))&nbsp;as&nbsp;'索引容量(MB)'from&nbsp;information_schema.tableswhere&nbsp;table_schema='mysql'; 4.查看指定数据库各表容量大小例：查看mysql库各表容量大小123456789selecttable_schema&nbsp;as&nbsp;'数据库',table_name&nbsp;as&nbsp;'表名',table_rows&nbsp;as&nbsp;'记录数',truncate(data_length/1024/1024, 2)&nbsp;as&nbsp;'数据容量(MB)',truncate(index_length/1024/1024, 2)&nbsp;as&nbsp;'索引容量(MB)'from&nbsp;information_schema.tableswhere&nbsp;table_schema='mysql'order&nbsp;by&nbsp;data_length desc, index_length desc;&nbsp;","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://easybhu.cn/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://easybhu.cn/tags/Mysql/"}]},{"title":"mysql json使用类型查询函数","slug":"mysql-json使用类型查询函数","date":"2020-02-02T09:35:58.000Z","updated":"2020-02-02T09:38:04.192Z","comments":true,"path":"2020/02/02/mysql-json使用类型查询函数/","link":"","permalink":"http://easybhu.cn/2020/02/02/mysql-json%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%9F%A5%E8%AF%A2%E5%87%BD%E6%95%B0/","excerpt":"","text":"一,对记录的操作1.创建有json字段的表-- 创建表 CREATE TABLE t_json(id INT PRIMARY KEY, sname VARCHAR(20) , info JSON);2.插入记录-- 插入含有json数组的记录 INSERT INTO t_json(id,sname,info) VALUES( 1, 'name1', JSON_ARRAY(1, \"abc\", NULL, TRUE, CURTIME())); -- 插入含有json对象的记录 INSERT INTO t_json(id,sname,info) VALUES( 2, 'name2', JSON_OBJECT(\"age\", 20, \"time\", now()));INSERT INTO t_json(id,sname,info) VALUES( 3, 'name3', '{\"age\":20, \"time\":\"2018-07-14 10:52:00\"}');3.查询记录-- 查询记录 SELECT sname,JSON_EXTRACT(info,'$.age') FROM t_json;SELECT sname,info-&gt;'$.age' FROM t_json;-- 查询key SELECT id,json_keys(info) FROM t_json;4.修改记录-- 增加键 UPDATE t_json SET info = json_set(info,'$.ip','192.168.1.1') WHERE id = 2;-- 变更值 UPDATE t_json SET info = json_set(info,'$.ip','192.168.1.2') WHERE id = 2;-- 删除键 UPDATE t_json SET info = json_remove(info,'$.ip') WHERE id = 2;二,创建json值函数1.JSON_ARRAY 生成json数组-- JSON_ARRAY(val1,val2,val3...) -- 生成一个包含指定元素的json数组。 SELECT JSON_ARRAY(1, \"abc\", NULL, TRUE, CURTIME()); -- [1, \"abc\", null, true, \"10:37:08.000000\"]2.JSON_OBJECT 生成json对象-- JSON_OBJECT(key1,val1,key2,val2...) -- 生成一个包含指定K-V对的json object。如果有key为NULL或参数个数为奇数，则抛错。 SELECT JSON_OBJECT('age', 20, 'time', now()); -- {\"id\": 87, \"name\": \"carrot\"}3.JSON_QUOTE 加\"号-- JSON_QUOTE(json_val) -- 将json_val用\"号括起来。 SELECT JSON_QUOTE('[1,2,3]'); -- \"[1,2,3]\"三,搜索json值函数1.JSON_CONTAINS 指定数据是否存在set @j = '{\"a\": 1, \"b\": 2, \"c\": {\"d\": 4}}'; -- JSON_CONTAINS(json_doc, val[, path]) -- 查询json文档是否在指定path包含指定的数据，包含则返回1，否则返回0。如果有参数为NULL或path不存在，则返回NULL。 SELECT JSON_CONTAINS(@j, '4', '$.c.d'); -- 12.JSON_CONTAINS_PATH 指定路径是否存在-- JSON_CONTAINS_PATH(json_doc, one_or_all, path[, path] ...) -- 查询是否存在指定路径，存在则返回1，否则返回0。如果有参数为NULL，则返回NULL。 -- one_or_all只能取值\"one\"或\"all\"，one表示只要有一个存在即可；all表示所有的都存在才行。 SELECT JSON_CONTAINS_PATH(@j, 'one', '$.a', '$.e'); -- 1SELECT JSON_CONTAINS_PATH(@j, 'all', '$.a', '$.c.d'); -- 13.JSON_EXTRACT 查找所有指定数据-- JSON_EXTRACT(json_doc, path[, path] ...) -- 从json文档里抽取数据。如果有参数有NULL或path不存在，则返回NULL。如果抽取出多个path，则返回的数据封闭在一个json array里。 set @j2 = '[10, 20, [30, 40]]';SELECT JSON_EXTRACT('[10, 20, [30, 40]]', '$[1]'); -- 20SELECT JSON_EXTRACT('[10, 20, [30, 40]]', '$[1]', '$[0]'); -- [20, 10]SELECT JSON_EXTRACT('[10, 20, [30, 40]]', '$[2][*]'); -- [30, 40]4.JSON_KEYS 查找所有指定键值-- JSON_KEYS(json_doc[, path]) -- 获取json文档在指定路径下的所有键值，返回一个json array。如果有参数为NULL或path不存在，则返回NULL。 SELECT JSON_KEYS('{\"a\": 1, \"b\": {\"c\": 30}}'); -- [\"a\", \"b\"]SELECT JSON_KEYS('{\"a\": 1, \"b\": {\"c\": 30}}', '$.b'); -- [\"c\"]SELECT id,json_keys(info) FROM t_json;5.JSON_SEARCH 查找所有指定值的位置-- JSON_SEARCH(json_doc, one_or_all, search_str[, escape_char[, path] ...]) -- 查询包含指定字符串的paths，并作为一个json array返回。如果有参数为NUL或path不存在，则返回NULL。 -- one_or_all：\"one\"表示查询到一个即返回；\"all\"表示查询所有。 -- search_str：要查询的字符串。 可以用LIKE里的'%'或‘_’匹配。 -- path：在指定path下查。 SET @j3 = '[\"abc\", [{\"k\": \"10\"}, \"def\"], {\"x\":\"abc\"}, {\"y\":\"bcd\"}]';SELECT JSON_SEARCH(@j3, 'one', 'abc'); -- \"$[0]\"SELECT JSON_SEARCH(@j3, 'all', 'abc'); -- [\"$[0]\", \"$[2].x\"]SELECT JSON_SEARCH(@j3, 'all', 'abc', NULL, '$[2]'); -- \"$[2].x\"SELECT JSON_SEARCH(@j3, 'all', '10'); -- \"$[1][0].k\"SELECT JSON_SEARCH(@j3, 'all', '%b%'); -- [\"$[0]\", \"$[2].x\", \"$[3].y\"]SELECT JSON_SEARCH(@j3, 'all', '%b%', NULL, '$[2]'); -- \"$[2].x\"四,修改json值函数1.JSON_ARRAY_APPEND&nbsp; 指定位置追加数组元素-- JSON_ARRAY_APPEND(json_doc, path, val[, path, val] ...) -- 在指定path的json array尾部追加val。如果指定path是一个json object，则将其封装成一个json array再追加。如果有参数为NULL，则返回NULL。 SET @j4 = '[\"a\", [\"b\", \"c\"], \"d\"]'; -- SELECT JSON_ARRAY_APPEND(@j4, '$[1][0]', 3); -- [\"a\", [[\"b\", 3], \"c\"], \"d\"] SET @j5 = '{\"a\": 1, \"b\": [2, 3], \"c\": 4}';SELECT JSON_ARRAY_APPEND(@j5, '$.b', 'x'); -- {\"a\": 1, \"b\": [2, 3, \"x\"], \"c\": 4} SELECT JSON_ARRAY_APPEND(@j5, '$.c', 'y'); -- {\"a\": 1, \"b\": [2, 3], \"c\": [4, \"y\"]}SELECT JSON_ARRAY_APPEND(@j5, '$', 'z'); -- [{\"a\": 1, \"b\": [2, 3], \"c\": 4}, \"z\"]2.JSON_ARRAY_INSERT 指定位置插入数组元素-- JSON_ARRAY_INSERT(json_doc, path, val[, path, val] ...) -- 在path指定的json array元素插入val，原位置及以右的元素顺次右移。如果path指定的数据非json array元素，则略过此val；如果指定的元素下标超过json array的长度，则插入尾部。 SET @j6 = '[\"a\", {\"b\": [1, 2]}, [3, 4]]';SELECT JSON_ARRAY_INSERT(@j6, '$[1]', 'x'); -- [\"a\", \"x\", {\"b\": [1, 2]}, [3, 4]]SELECT JSON_ARRAY_INSERT(@j6, '$[100]', 'x'); -- [\"a\", {\"b\": [1, 2]}, [3, 4], \"x\"]SELECT JSON_ARRAY_INSERT(@j6, '$[1].b[0]', 'x'); -- [\"a\", {\"b\": [\"x\", 1, 2]}, [3, 4]]SELECT JSON_ARRAY_INSERT(@j6, '$[0]', 'x', '$[3][1]', 'y'); -- [\"x\", \"a\", {\"b\": [1, 2]}, [3, \"y\", 4]]3.JSON_INSERT 指定位置插入-- JSON_INSERT(json_doc, path, val[, path, val] ...) -- 在指定path下插入数据，如果path已存在，则忽略此val（不存在才插入）。 SET @j7 = '{ \"a\": 1, \"b\": [2, 3]}';SELECT JSON_INSERT(@j7, '$.a', 10, '$.c', '[true, false]'); -- {\"a\": 1, \"b\": [2, 3], \"c\": \"[true, false]\"}4.JSON_REPLACE 指定位置替换-- JSON_REPLACE(json_doc, path, val[, path, val] ...) -- 替换指定路径的数据，如果某个路径不存在则略过（存在才替换）。如果有参数为NULL，则返回NULL。 SELECT JSON_REPLACE(@j7, '$.a', 10, '$.c', '[true, false]'); -- {\"a\": 10, \"b\": [2, 3]}5.JSON_SET 指定位置设置-- JSON_SET(json_doc, path, val[, path, val] ...) -- 设置指定路径的数据（不管是否存在）。如果有参数为NULL，则返回NULL。 SELECT JSON_SET(@j7, '$.a', 10, '$.c', '[true, false]'); -- {\"a\": 10, \"b\": [2, 3], \"c\": \"[true, false]\"}6.JSON_MERGE 合并-- JSON_MERGE(json_doc, json_doc[, json_doc] ...) -- merge多个json文档。规则如下： -- 如果都是json array，则结果自动merge为一个json array； -- 如果都是json object，则结果自动merge为一个json object； -- 如果有多种类型，则将非json array的元素封装成json array再按照规则一进行mege。 SELECT JSON_MERGE('[1, 2]', '[true, false]'); -- [1, 2, true, false]SELECT JSON_MERGE('{\"name\": \"x\"}', '{\"id\": 47}'); -- {\"id\": 47, \"name\": \"x\"}SELECT JSON_MERGE('1', 'true'); -- [1, true]SELECT JSON_MERGE('[1, 2]', '{\"id\": 47}'); -- [1, 2, {\"id\": 47}]7.JSON_REMOVE 指定位置移除-- JSON_REMOVE(json_doc, path[, path] ...) -- 移除指定路径的数据，如果某个路径不存在则略过此路径。如果有参数为NULL，则返回NULL。 SET @j8 = '[\"a\", [\"b\", \"c\"], \"d\"]';SELECT JSON_REMOVE(@j8, '$[1]'); -- [\"a\", \"d\"]8.JSON_UNQUOTE 去\"号-- JSON_UNQUOTE(val) -- 去掉val的引号。如果val为NULL，则返回NULL。 SELECT JSON_UNQUOTE(\"\\\"123\\\"\"); -- 123五,返回json值属性的函数1.JSON_DEPTH 深度-- JSON_DEPTH(json_doc) -- 获取json文档的深度。如果参数为NULL，则返回NULL。 -- 空的json array、json object或标量的深度为1。 SELECT JSON_DEPTH('{}'), JSON_DEPTH('[]'), JSON_DEPTH('true'); -- 1 1 1SELECT JSON_DEPTH('[10, 20]'), JSON_DEPTH('[[], {}]'); -- 2 2SELECT JSON_DEPTH('[10, {\"a\": 20}]'); -- 32.JSON_LENGTH 长度-- JSON_LENGTH(json_doc[, path]) -- 获取指定路径下的长度。如果参数为NULL，则返回NULL。 -- 长度的计算规则： -- 标量的长度为1； -- json array的长度为元素的个数； -- json object的长度为key的个数。 SELECT JSON_LENGTH('[1, 2, {\"a\": 3}]'); -- 3SELECT JSON_LENGTH('{\"a\": 1, \"b\": {\"c\": 30}}'); -- 2SELECT JSON_LENGTH('{\"a\": 1, \"b\": {\"c\": 30}}', '$.b'); -- 13.JSON_TYPE 类型-- JSON_TYPE(json_val) -- 获取json文档的具体类型。如果参数为NULL，则返回NULL。 select JSON_TYPE('[1,2]'); -- ARRAY4.JSON_VALID 是否有效json格式-- JSON_VALID(val) -- 判断val是否为有效的json格式，是为1，不是为0。如果参数为NUL，则返回NULL。 SELECT JSON_VALID('{\"a\": 1}'); -- 1SELECT JSON_VALID('hello'), JSON_VALID('\"hello\"'); -- 1附录:JSON_ARRAY 生成json数组 JSON_OBJECT 生成json对象 JSON_QUOTE 加\"号 JSON_CONTAINS 指定数据是否存在 JSON_CONTAINS_PATH 指定路径是否存在 JSON_EXTRACT 查找所有指定数据 JSON_KEYS 查找所有指定键值 JSON_SEARCH 查找所有指定值的位置 JSON_ARRAY_APPEND 指定位置追加数组元素 JSON_ARRAY_INSERT 指定位置插入数组元素 JSON_INSERT 指定位置插入 JSON_REPLACE 指定位置替换 JSON_SET 指定位置设置 JSON_MERGE 合并 JSON_REMOVE 指定位置移除 JSON_UNQUOTE 去\"号 JSON_DEPTH 深度 JSON_LENGTH 长度 JSON_TYPE 类型 JSON_VALID 是否有效json格式&nbsp;函数名描述JSON_APPEND()（废弃的5.7.9）JSON文件追加数据JSON_ARRAY()创建JSON数组JSON_ARRAY_APPEND()JSON文件追加数据JSON_ARRAY_INSERT()插入JSON数组-&gt;在评估路径返回JSON列值；相当于json_extract()。JSON_CONTAINS()是否包含特定对象的JSON文档路径JSON_CONTAINS_PATH()无论是JSON文件包含任何数据路径JSON_DEPTH()JSON文档的最大深度JSON_EXTRACT()从JSON文档返回数据-&gt;&gt;在评估路径和结束引语结果返回JSON列值；相当于json_unquote（json_extract()）。JSON_INSERT()将数据插入到JSON文档JSON_KEYS()从JSON文件密钥数组JSON_LENGTH()在JSON文档中的元素数JSON_MERGE()（废弃的5.7.22）合并的JSON文件，保存重复键。不json_merge_preserve()的同义词JSON_MERGE_PATCH()合并的JSON文件，免去重复键的值JSON_MERGE_PRESERVE()合并的JSON文件，保存重复键JSON_OBJECT()创建JSON对象JSON_PRETTY()版画在人类可读的格式JSON文档，每个数组元素或对象成员打印在新的行中，缩进两个空格就其母。JSON_QUOTE()引用JSON文档JSON_REMOVE()从JSON文件中删除数据JSON_REPLACE()在JSON文件的值替换JSON_SEARCH()在JSON文件价值路径JSON_SET()将数据插入到JSON文档JSON_STORAGE_SIZE()用于一个JSON文件的二进制表示形式存储空间；一个JSON柱，空间时使用的文档插入到任何部分更新之前，JSON_TYPE()JSON值类型JSON_UNQUOTE()JSON值而言JSON_VALID()JSON值是否是有效的","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://easybhu.cn/categories/Mysql/"},{"name":"Json","slug":"Mysql/Json","permalink":"http://easybhu.cn/categories/Mysql/Json/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://easybhu.cn/tags/Mysql/"},{"name":"Json","slug":"Json","permalink":"http://easybhu.cn/tags/Json/"}]},{"title":"PHP中的 抽象类（abstract class）和 接口（interface）","slug":"PHP中的-抽象类（abstract-class）和-接口（interface）","date":"2020-02-02T09:29:56.000Z","updated":"2020-02-02T09:31:55.013Z","comments":true,"path":"2020/02/02/PHP中的-抽象类（abstract-class）和-接口（interface）/","link":"","permalink":"http://easybhu.cn/2020/02/02/PHP%E4%B8%AD%E7%9A%84-%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88abstract-class%EF%BC%89%E5%92%8C-%E6%8E%A5%E5%8F%A3%EF%BC%88interface%EF%BC%89/","excerpt":"","text":"抽象类abstract class1 ．抽象类是指在 class 前加了 abstract 关键字且存在抽象方法（在类方法 function 关键字前加了 abstract 关键字）的类。2 ．抽象类不能被直接实例化。抽象类中只定义（或部分实现）子类需要的方法。子类可以通过继承抽象类并通过实现抽象类中的所有抽象方法，使抽象类具体化。3 ．如果子类需要实例化，前提是它实现了抽象类中的所有抽象方法。如果子类没有全部实现抽象类中的所有抽象方法，那么该子类也是一个抽象类，必须在 class 前面加上 abstract 关键字，并且不能被实例化。abstract class A{ /** 抽象类中可以定义变量 */ protected = 0; private = 1; public = 2; /** 也可以定义非抽象方法 */ public function my_print() { echo \"hello,world/n\"; } /** * 大多数情况下，抽象类至少含有一个抽象方法。抽象方法用abstract关键字声明，其中不能有具体内容。 * 可以像声明普通类方法那样声明抽象方法，但是要以分号而不是方法体结束。也就是说抽象方法在抽象类中不能被实现，也就是没有函数体“{some codes}”。 */ abstract protected function abstract_func1(); abstract protected function abstract_func2();}abstract class B extends A{ public function abstract_func1() { echo \"implement the abstract_func1 in class A/n\"; } /** 这么写在zend studio 8中会报错*/ //abstract protected function abstract_func2();}class C extends B{ public function abstract_func2() { echo \"implement the abstract_func2 in class A/n\"; }}4 ．如果像下面这样创建了一个继承自 A 的子类 B ，但是不实现抽象方法 abstract_func() ：Class B extends A{};那么程序将出现以下错误：Fatal error: Class B contains 1 abstract method and must therefore be declared abstract or implement the remaining methods (A::abstract_func)5 ．如果 B 实现了抽象方法 abstract_func() ，那么 B 中 abstract_func() 方法的访问控制不能比 A 中 abstract_func() 的访问控制更严格，也就是说：(1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果 A 中 abstract_func() 声明为 public ，那么 B 中 abstract_func() 的声明只能是 public ，不能是 protected 或 private(2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果 A 中 abstract_func() 声明为 protected ，那么 B 中 abstract_func() 的声明可以是 public 或 protected ，但不能是 private(3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果 A 中 abstract_func() 声明为 private ，嘿嘿，不能定义为 private 哦！（ Fatal error : Abstract function A::abstract_func() cannot be declared private ）二、 接口interface1 ．抽象类提供了具体实现的标准，而接口则是纯粹的模版。接口只定义功能，而不包含实现的内容。接口用关键字 interface 来声明。2 ． interface 是完全抽象的，只能声明方法，而且只能声明 public 的方法，不能声明 private 及 protected 的方法，不能定义方法体，也不能声明实例变量 。然而， interface 却可以声明常量变量 。但将常量变量放在 interface 中违背了其作为接口的作用而存在的宗旨，也混淆了 interface 与类的不同价值。如果的确需要，可以将其放在相应的 abstract class 或 Class 中。interface iA{ const AVAR=3; public function iAfunc1(); public function iAfunc2();}echo iA:: AVAR;3 ．任何实现接口的类都要实现接口中所定义的所有方法class E implements iA{ public function iAfunc1(){echo \"in iAfunc1\";} public function iAfunc2(){echo \"in iAfunc2\";}}否则该类必须声明为 abstract 。abstract class E implements iA{}4 ．一个类可以在声明中使用 implements 关键字来实现某个接口。这么做之后，实现接口的具体过程和继承一个仅包含抽象方法的抽象类是一样的。一个类可以同时继承一个父类和实现任意多个接口。 extends 子句应该在 implements 子句之前。 PHP 只支持继承自一个父类，因此 extends 关键字后只能跟一个类名。interface iB{ public function iBfunc1(); public function iBfunc2();}class D extends A implements iA,iB{ public function abstract_func1() { echo \"implement the abstract_func1 in class A/n\"; } public function abstract_func2() { echo \"implement the abstract_func2 in class A/n\"; } public function iAfunc1(){echo \"in iAfunc1\";} public function iAfunc2(){echo \"in iAfunc2\";} public function iBfunc1(){echo \"in iBfunc1\";} public function iBfunc2(){echo \"in iBfunc2\";}} class D extends B implements iA,iB{ public function abstract_func1() { parent::abstract_func1(); echo \"override the abstract_func1 in class A/n\"; } public function abstract_func2() { echo \"implement the abstract_func2 in class A/n\"; } public function iAfunc1(){echo \"in iAfunc1\";} public function iAfunc2(){echo \"in iAfunc2\";} public function iBfunc1(){echo \"in iBfunc1\";} public function iBfunc2(){echo \"in iBfunc2\";}}5 ．接口不可以实现另一个接口，但可以继承多个interface iC extends iA,iB{}class F implements iC{ public function iAfunc1(){echo \"in iAfunc1\";} public function iAfunc2(){echo \"in iAfunc2\";} public function iBfunc1(){echo \"in iBfunc1\";} public function iBfunc2(){echo \"in iBfunc2\";}}三、 抽象类和接口的异同1. 相同点：(1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 两者都是抽象类，都不能实例化。(2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interface 实现类及 abstract class 的子类都必须要实现已经声明的抽象方法。2. 不同点：(1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interface 需要实现，要用 implements ，而 abstract class 需要继承，要用 extends 。(2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一个类可以实现多个 interface ，但一个类只能继承一个 abstract class 。(3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interface 强调特定功能的实现，而 abstract class 强调所属关系。(4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 尽管 interface 实现类及 abstract class 的子类都必须要实现相应的抽象方法，但实现的形式不同。 interface 中的每一个方法都是抽象方法，都只是声明的 (declaration, 没有方法体 ) ，实现类必须要实现。而 abstract class 的子类可以有选择地实现。这个选择有两点含义： a) abstract class 中并非所有的方法都是抽象的，只有那些冠有 abstract 的方法才是抽象的，子类必须实现。那些没有 abstract 的方法，在 abstract class 中必须定义方法体； b) abstract class 的子类在继承它时，对非抽象方法既可以直接继承，也可以覆盖；而对抽象方法，可以选择实现，也可以留给其子类来实现，但此类必须也声明为抽象类。既是抽象类，当然也不能实例化。(5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abstract class 是 interface 与 class 的中介。 abstract class 在 interface 及 class 中起到了承上启下的作用。一方面， abstract class 是抽象的，可以声明抽象方法，以规范子类必须实现的功能；另一方面，它又可以定义缺省的方法体，供子类直接使用或覆盖。另外，它还可以定义自己的实例变量，以供子类通过继承来使用。(6)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 接口中的抽象方法前不用也不能加 abstract 关键字，默认隐式就是抽象方法，也不能加 final 关键字来防止抽象方法的继承。而抽象类中抽象方法前则必须加上 abstract 表示显示声明为抽象方法。(7)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 接口中的抽象方法默认是 public 的，也只能是 public 的，不能用 private ， protected 修饰符修饰。而抽象类中的抽象方法则可以用 public ， protected 来修饰，但不能用 private 。3. interface 的应用场合(1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 类与类之间需要特定的接口进行协调，而不在乎其如何实现。(2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 作为能够实现特定功能的标识存在，也可以是什么接口方法都没有的纯粹标识。(3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 需要将一组类视为单一的类，而调用者只通过接口来与这组类发生联系。(4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 需要实现特定的多项功能，而这些功能之间可能完全没有任何联系。4. abstract class 的应用场合一句话，在既需要统一的接口，又需要实例变量或缺省的方法的情况下，就可以使用它。最常见的有：(1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 定义了一组接口，但又不想强迫每个实现类都必须实现所有的接口。可以用 abstract class 定义一组方法体，甚至可以是空方法体，然后由子类选择自己所感兴趣的方法来覆盖。(2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 某些场合下，只靠纯粹的接口不能满足类与类之间的协调，还必需类中表示状态的变量来区别不同的关系。 abstract 的中介作用可以很好地满足这一点。(3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 规范了一组相互协调的方法，其中一些方法是共同的，与状态无关的，可以共享的，无需子类分别实现；而另一些方法却需要各个子类根据自己特定的状态来实现特 定的功能 。--------------------- 版权声明：本文为CSDN博主「sunlylorn」的原创文章，遵循CC 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/sunlylorn/article/details/6124319","categories":[{"name":"Php","slug":"Php","permalink":"http://easybhu.cn/categories/Php/"}],"tags":[{"name":"Php","slug":"Php","permalink":"http://easybhu.cn/tags/Php/"},{"name":"抽象类","slug":"抽象类","permalink":"http://easybhu.cn/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"}]},{"title":"MYSQL 解锁与锁表","slug":"MYSQL 解锁与锁表","date":"2020-02-02T09:17:59.000Z","updated":"2020-02-02T09:22:07.430Z","comments":true,"path":"2020/02/02/MYSQL 解锁与锁表/","link":"","permalink":"http://easybhu.cn/2020/02/02/MYSQL%20%E8%A7%A3%E9%94%81%E4%B8%8E%E9%94%81%E8%A1%A8/","excerpt":"","text":"MySQL锁概述相对其他数据库而言，MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。比如，MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）；BDB存储引擎采用的是页面锁（page-level locking），但也支持表级锁；InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。MySQL这3种锁的特性可大致归纳如下。开销、加锁速度、死锁、粒度、并发性能表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。MyISAM表锁MyISAM存储引擎只支持表锁，这也是MySQL开始几个版本中唯一支持的锁类型。随着应用对事务完整性和并发性要求的不断提高，MySQL才开始开发基于事务的存储引擎，后来慢慢出现了支持页锁的BDB存储引擎和支持行锁的InnoDB存储引擎（实际 InnoDB是单独的一个公司，现在已经被Oracle公司收购）。但是MyISAM的表锁依然是使用最为广泛的锁类型。本节将详细介绍MyISAM表锁的使用。查询表级锁争用情况可以通过检查table_locks_waited和table_locks_immediate状态变量来分析系统上的表锁定争夺：mysql&gt;&nbsp;show status like 'table%'; +-----------------------+-------+ | Variable_name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Value | +-----------------------+-------+ | Table_locks_immediate | 2979&nbsp; | | Table_locks_waited&nbsp;&nbsp;&nbsp; | 0&nbsp;&nbsp;&nbsp;&nbsp; | +-----------------------+-------+2 rows in set (0.00 sec))如果Table_locks_waited的值比较高，则说明存在着较严重的表级锁争用情况。获取InnoDB行锁争用情况可以通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况：mysql&gt;&nbsp;show status like 'innodb_row_lock%'; +-------------------------------+-------+ | Variable_name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Value | +-------------------------------+-------+ | InnoDB_row_lock_current_waits | 0&nbsp;&nbsp;&nbsp;&nbsp; | | InnoDB_row_lock_time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 0&nbsp;&nbsp;&nbsp;&nbsp; | | InnoDB_row_lock_time_avg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 0&nbsp;&nbsp;&nbsp;&nbsp; | | InnoDB_row_lock_time_max&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 0&nbsp;&nbsp;&nbsp;&nbsp; | | InnoDB_row_lock_waits&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 0&nbsp;&nbsp;&nbsp;&nbsp; | +-------------------------------+-------+ 5 rows in set (0.01 sec)如果发现锁争用比较严重，如InnoDB_row_lock_waits和InnoDB_row_lock_time_avg的值比较高，还可以通过&nbsp;解锁第一种show processlist;找到锁进程，kill id ;&nbsp;第二种mysql&gt;UNLOCK TABLES;锁表锁定数据表，避免在备份过程中，表被更新mysql&gt;LOCK TABLES tbl_name READ;为表增加一个写锁定：mysql&gt;LOCK TABLES tbl_name WRITE;","categories":[{"name":"Mysql","slug":"Mysql","permalink":"http://easybhu.cn/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://easybhu.cn/tags/Mysql/"}]},{"title":"JSON与JS数组互相转换","slug":"JSON与JS数组互相转换","date":"2020-02-02T09:17:59.000Z","updated":"2020-02-02T09:21:30.433Z","comments":true,"path":"2020/02/02/JSON与JS数组互相转换/","link":"","permalink":"http://easybhu.cn/2020/02/02/JSON%E4%B8%8EJS%E6%95%B0%E7%BB%84%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"Please Write Article1. JS数组转换JSONvar json = JSON.stringify(js_array)2. JSON转换JS数组var js_array = JSON.parse(json)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://easybhu.cn/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://easybhu.cn/tags/JavaScript/"},{"name":"Js","slug":"Js","permalink":"http://easybhu.cn/tags/Js/"}]},{"title":"GO 设置 GOROOT 和 GOPATH","slug":"GO 设置 GOROOT 和 GOPATH","date":"2020-02-02T09:17:59.000Z","updated":"2020-02-02T09:20:43.691Z","comments":true,"path":"2020/02/02/GO 设置 GOROOT 和 GOPATH/","link":"","permalink":"http://easybhu.cn/2020/02/02/GO%20%E8%AE%BE%E7%BD%AE%20GOROOT%20%E5%92%8C%20GOPATH/","excerpt":"","text":"go 里面有两个非常重要的环境变量 GOROOT 和 GOPATH，其中 GOROOT 是安装 go 的路径，而 GOPATH 是我们定义的自己的工作空间。如果在安装的时候是一路 next 完的，那么默认就配置好了 ，无需手动配置。如果在安装的时候修改了默认的安装路径，那么可能需要自己添加一下 。首先在环境变量中添加 GOPATH，值为 go 的安装目录：然后在环境变量 PATH 中添加 go 安装目录下的 bin 文件夹。接着添加一个环境变量 GOPATH，值为你自己希望的工作目录。最后重启一下 命令行工具，输入 go env 命令即可查看：Tips:一定要记得重启下命令行工具，cmd 或者 cmder 啥的，不然修改的环境变量没有生效，我一开始忘记了重启，纳闷半天为啥没生效。原文：https://blog.csdn.net/xs20691718/article/details/78089163","categories":[{"name":"GoLang","slug":"GoLang","permalink":"http://easybhu.cn/categories/GoLang/"}],"tags":[{"name":"GoLang","slug":"GoLang","permalink":"http://easybhu.cn/tags/GoLang/"}]},{"title":"RESTful 架构详解","slug":"RESTful 架构详解","date":"2020-02-02T09:17:59.000Z","updated":"2020-02-02T09:23:26.212Z","comments":true,"path":"2020/02/02/RESTful 架构详解/","link":"","permalink":"http://easybhu.cn/2020/02/02/RESTful%20%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"1. 什么是RESTREST全称是Representational State Transfer，中文意思是表述（编者注：通常译为表征）性状态转移。 它首次出现在2000年Roy Fielding的博士论文中，Roy Fielding是HTTP规范的主要编写者之一。 他在论文中提到：”我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。REST指的是一组架构约束条件和原则。” 如果一个架构符合REST的约束条件和原则，我们就称它为RESTful架构。REST本身并没有创造新的技术、组件或服务，而隐藏在RESTful背后的理念就是使用Web的现有特征和能力， 更好地使用现有Web标准中的一些准则和约束。虽然REST本身受Web技术的影响很深， 但是理论上REST架构风格并不是绑定在HTTP上，只不过目前HTTP是唯一与REST相关的实例。 所以我们这里描述的REST也是通过HTTP实现的REST。2. 理解RESTful要理解RESTful架构，需要理解Representational State Transfer这个词组到底是什么意思，它的每一个词都有些什么涵义。下面我们结合REST原则，围绕资源展开讨论，从资源的定义、获取、表述、关联、状态变迁等角度，列举一些关键概念并加以解释。资源与URI统一资源接口资源的表述资源的链接状态的转移2. 1 资源与URIREST全称是表述性状态转移，那究竟指的是什么的表述? 其实指的就是资源。任何事物，只要有被引用到的必要，它就是一个资源。资源可以是实体(例如手机号码)，也可以只是一个抽象概念(例如价值) 。下面是一些资源的例子：某用户的手机号码某用户的个人信息最多用户订购的GPRS套餐两个产品之间的依赖关系某用户可以办理的优惠套餐某手机号码的潜在价值要让一个资源可以被识别，需要有个唯一标识，在Web中这个唯一标识就是URI(Uniform Resource Identifier)。URI既可以看成是资源的地址，也可以看成是资源的名称。如果某些信息没有使用URI来表示，那它就不能算是一个资源， 只能算是资源的一些信息而已。URI的设计应该遵循可寻址性原则，具有自描述性，需要在形式上给人以直觉上的关联。这里以github网站为例，给出一些还算不错的URI：https://github.com/githttps://github.com/git/githttps://github.com/git/git/blob/master/block-sha1/sha1.hhttps://github.com/git/git/commit/e3af72cdafab5993d18fae056f87e1d675913d08https://github.com/git/git/pullshttps://github.com/git/git/pulls?state=closedhttps://github.com/git/git/compare/master…next下面让我们来看看URI设计上的一些技巧:使用_或-来让URI可读性更好曾经Web上的URI都是冰冷的数字或者无意义的字符串，但现在越来越多的网站使用_或-来分隔一些单词，让URI看上去更为人性化。 例如国内比较出名的开源中国社区，它上面的新闻地址就采用这种风格， 如http://www.oschina.net/news/38119/oschina-translate-reward-plan。使用/来表示资源的层级关系例如上述/git/git/commit/e3af72cdafab5993d18fae056f87e1d675913d08就表示了一个多级的资源， 指的是git用户的git项目的某次提交记录，又例如/orders/2012/10可以用来表示2012年10月的订单记录。使用?用来过滤资源很多人只是把?简单的当做是参数的传递，很容易造成URI过于复杂、难以理解。可以把?用于对资源的过滤， 例如/git/git/pulls用来表示git项目的所有推入请求，而/pulls?state=closed用来表示git项目中已经关闭的推入请求， 这种URL通常对应的是一些特定条件的查询结果或算法运算结果。,或;可以用来表示同级资源的关系有时候我们需要表示同级资源的关系时，可以使用,或;来进行分割。例如哪天github可以比较某个文件在随意两次提交记录之间的差异，或许可以使用/git/git /block-sha1/sha1.h/compare/e3af72cdafab5993d18fae056f87e1d675913d08;bd63e61bdf38e872d5215c07b264dcc16e4febca作为URI。 不过，现在github是使用…来做这个事情的，例如/git/git/compare/master…next。2. 2 统一资源接口RESTful架构应该遵循统一接口原则，统一接口包含了一组受限的预定义的操作，不论什么样的资源，都是通过使用相同的接口进行资源的访问。接口应该使用标准的HTTP方法如GET，PUT和POST，并遵循这些方法的语义。如果按照HTTP方法的语义来暴露资源，那么接口将会拥有安全性和幂等性的特性，例如GET和HEAD请求都是安全的， 无论请求多少次，都不会改变服务器状态。而GET、HEAD、PUT和DELETE请求都是幂等的，无论对资源操作多少次， 结果总是一样的，后面的请求并不会产生比第一次更多的影响。下面列出了GET，DELETE，PUT和POST的典型用法:GET安全且幂等获取表示变更时获取表示（缓存）200（OK） – 表示已在响应中发出204（无内容） – 资源有空表示301（Moved Permanently） – 资源的URI已被更新303（See Other） – 其他（如，负载均衡）304（not modified）- 资源未更改（缓存）400 （bad request）- 指代坏请求（如，参数错误）404 （not found）- 资源不存在406 （not acceptable）- 服务端不支持所需表示500 （internal server error）- 通用错误响应503 （Service Unavailable）- 服务端当前无法处理请求POST不安全且不幂等使用服务端管理的（自动产生）的实例号创建资源创建子资源部分更新资源如果没有被修改，则不过更新资源（乐观锁）200（OK）- 如果现有资源已被更改201（created）- 如果新资源被创建202（accepted）- 已接受处理请求但尚未完成（异步处理）301（Moved Permanently）- 资源的URI被更新303（See Other）- 其他（如，负载均衡）400（bad request）- 指代坏请求404 （not found）- 资源不存在406 （not acceptable）- 服务端不支持所需表示409 （conflict）- 通用冲突412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突）415 （unsupported media type）- 接受到的表示不受支持500 （internal server error）- 通用错误响应503 （Service Unavailable）- 服务当前无法处理请求PUT不安全但幂等用客户端管理的实例号创建一个资源通过替换的方式更新资源如果未被修改，则更新资源（乐观锁）200 （OK）- 如果已存在资源被更改201 （created）- 如果新资源被创建301（Moved Permanently）- 资源的URI已更改303 （See Other）- 其他（如，负载均衡）400 （bad request）- 指代坏请求404 （not found）- 资源不存在406 （not acceptable）- 服务端不支持所需表示409 （conflict）- 通用冲突412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突）415 （unsupported media type）- 接受到的表示不受支持500 （internal server error）- 通用错误响应503 （Service Unavailable）- 服务当前无法处理请求DELETE不安全但幂等删除资源200 （OK）- 资源已被删除301 （Moved Permanently）- 资源的URI已更改303 （See Other）- 其他，如负载均衡400 （bad request）- 指代坏请求404 （not found）- 资源不存在409 （conflict）- 通用冲突500 （internal server error）- 通用错误响应503 （Service Unavailable）- 服务端当前无法处理请求下面我们来看一些实践中常见的问题:POST和PUT用于创建资源时有什么区别?POST和PUT在创建资源的区别在于，所创建的资源的名称(URI)是否由客户端决定。 例如为我的博文增加一个java的分类，生成的路径就是分类名/categories/java，那么就可以采用PUT方法。不过很多人直接把POST、GET、PUT、DELETE直接对应上CRUD，例如在一个典型的rails实现的RESTful应用中就是这么做的。我认为，这是因为rails默认使用服务端生成的ID作为URI的缘故，而不少人就是通过rails实践REST的，所以很容易造成这种误解。客户端不一定都支持这些HTTP方法吧?的确有这种情况，特别是一些比较古老的基于浏览器的客户端，只能支持GET和POST两种方法。在实践上，客户端和服务端都可能需要做一些妥协。例如rails框架就支持通过隐藏参数_method=DELETE来传递真实的请求方法， 而像Backbone这样的客户端MVC框架则允许传递_method传输和设置X-HTTP-Method-Override头来规避这个问题。统一接口是否意味着不能扩展带特殊语义的方法?统一接口并不阻止你扩展方法，只要方法对资源的操作有着具体的、可识别的语义即可，并能够保持整个接口的统一性。像WebDAV就对HTTP方法进行了扩展，增加了LOCK、UPLOCK等方法。而github的API则支持使用PATCH方法来进行issue的更新，例如:PATCH /repos/:owner/:repo/issues/:number不过，需要注意的是，像PATCH这种不是HTTP标准方法的，服务端需要考虑客户端是否能够支持的问题。统一资源接口对URI有什么指导意义?统一资源接口要求使用标准的HTTP方法对资源进行操作，所以URI只应该来表示资源的名称，而不应该包括资源的操作。通俗来说，URI不应该使用动作来描述。例如，下面是一些不符合统一接口要求的URI:GET /getUser/1POST /createUserPUT /updateUser/1DELETE /deleteUser/1如果GET请求增加计数器，这是否违反安全性?安全性不代表请求不产生副作用，例如像很多API开发平台，都对请求流量做限制。像github，就会限制没有认证的请求每小时只能请求60次。但客户端不是为了追求副作用而发出这些GET或HEAD请求的，产生副作用是服务端”自作主张”的。另外，服务端在设计时，也不应该让副作用太大，因为客户端认为这些请求是不会产生副作用的。直接忽视缓存可取吗?即使你按各个动词的原本意图来使用它们，你仍可以轻易禁止缓存机制。 最简单的做法就是在你的HTTP响应里增加这样一个报头： Cache-control: no-cache。 但是，同时你也对失去了高效的缓存与再验证的支持(使用Etag等机制)。对于客户端来说，在为一个REST式服务实现程序客户端时，也应该充分利用现有的缓存机制，以免每次都重新获取表示。响应代码的处理有必要吗?HTTP的响应代码可用于应付不同场合，正确使用这些状态代码意味着客户端与服务器可以在一个具备较丰富语义的层次上进行沟通。例如，201（”Created”）响应代码表明已经创建了一个新的资源，其URI在Location响应报头里。假如你不利用HTTP状态代码丰富的应用语义，那么你将错失提高重用性、增强互操作性和提升松耦合性的机会。如果这些所谓的RESTful应用必须通过响应实体才能给出错误信息，那么SOAP就是这样的了，它就能够满足了。2. 3 资源的表述上面提到，客户端通过HTTP方法可以获取资源，是吧? 不，确切的说，客户端获取的只是资源的表述而已。 资源在外界的具体呈现，可以有多种表述(或成为表现、表示)形式，在客户端和服务端之间传送的也是资源的表述，而不是资源本身。 例如文本资源可以采用html、xml、json等格式，图片可以使用PNG或JPG展现出来。资源的表述包括数据和描述数据的元数据，例如，HTTP头”Content-Type” 就是这样一个元数据属性。那么客户端如何知道服务端提供哪种表述形式呢?答案是可以通过HTTP内容协商，客户端可以通过Accept头请求一种特定格式的表述，服务端则通过Content-Type告诉客户端资源的表述形式。以github为例，请求某组织资源的json格式的表述形式:&nbsp;假如github也能够支持xml格式的表述格式，那么结果就是这样的:&nbsp;下面我们来看一些实践上常见的设计:在URI里边带上版本号有些API在URI里边带上版本号，例如:http://api.example.com/1.0/foohttp://api.example.com/1.2/foohttp://api.example.com/2.0/foo如果我们把版本号理解成资源的不同表述形式的话，就应该只是用一个URL，并通过Accept头部来区分，还是以github为例，它的Accept的完整格式是:application/vnd.github[.version].param[+json]对于v3版本的话，就是Accept: application/vnd.github.v3。对于上面的例子，同理可以使用使用下面的头部:Accept: vnd.example-com.foo+json; version=1.0Accept: vnd.example-com.foo+json; version=1.2Accept: vnd.example-com.foo+json; version=2.0使用URI后缀来区分表述格式像rails框架，就支持使用/users.xml或/users.json来区分不同的格式。 这样的方式对于客户端来说，无疑是更为直观，但混淆了资源的名称和资源的表述形式。 我个人认为，还是应该优先使用内容协商来区分表述格式。如何处理不支持的表述格式当服务器不支持所请求的表述格式，那么应该怎么办？若服务器不支持，它应该返回一个HTTP 406响应，表示拒绝处理该请求。下面以github为例，展示了一个请求XML表述资源的结果：&nbsp;2. 4 资源的链接我们知道REST是使用标准的HTTP方法来操作资源的，但仅仅因此就理解成带CURD的Web数据库架构就太过于简单了。这种反模式忽略了一个核心概念：”超媒体即应用状态引擎（hypermedia as the engine of application state）”。 超媒体是什么?当你浏览Web网页时，从一个连接跳到一个页面，再从另一个连接跳到另外一个页面，就是利用了超媒体的概念：把一个个把资源链接起来.要达到这个目的，就要求在表述格式里边加入链接来引导客户端。在《RESTful Web Services》一书中，作者把这种具有链接的特性成为连通性。下面我们具体来看一些例子。下面展示的是github获取某个组织下的项目列表的请求，可以看到在响应头里边增加Link头告诉客户端怎么访问下一页和最后一页的记录。 而在响应体里边，用url来链接项目所有者和项目地址。 又例如下面这个例子，创建订单后通过链接引导客户端如何去付款。上面的例子展示了如何使用超媒体来增强资源的连通性。很多人在设计RESTful架构时，使用很多时间来寻找漂亮的URI，而忽略了超媒体。所以，应该多花一些时间来给资源的表述提供链接，而不是专注于”资源的CRUD”。2. 5 状态的转移有了上面的铺垫，再讨论REST里边的状态转移就会很容易理解了。不过，我们先来讨论一下REST原则中的无状态通信原则。初看一下，好像自相矛盾了，既然无状态，何来状态转移一说?其实，这里说的无状态通信原则，并不是说客户端应用不能有状态，而是指服务端不应该保存客户端状态。2. 5.1 应用状态与资源状态实际上，状态应该区分应用状态和资源状态，客户端负责维护应用状态，而服务端维护资源状态。客户端与服务端的交互必须是无状态的，并在每一次请求中包含处理该请求所需的一切信息。服务端不需要在请求间保留应用状态，只有在接受到实际请求的时候，服务端才会关注应用状态。这种无状态通信原则，使得服务端和中介能够理解独立的请求和响应。在多次请求中，同一客户端也不再需要依赖于同一服务器，方便实现高可扩展和高可用性的服务端。但有时候我们会做出违反无状态通信原则的设计，例如利用Cookie跟踪某个服务端会话状态，常见的像J2EE里边的JSESSIONID。这意味着，浏览器随各次请求发出去的Cookie是被用于构建会话状态的。当然，如果Cookie保存的是一些服务器不依赖于会话状态即可验证的信息（比如认证令牌），这样的Cookie也是符合REST原则的。2. 5.2 应用状态的转移状态转移到这里已经很好理解了， “会话”状态不是作为资源状态保存在服务端的，而是被客户端作为应用状态进行跟踪的。客户端应用状态在服务端提供的超媒体的指引下发生变迁。服务端通过超媒体告诉客户端当前状态有哪些后续状态可以进入。这些类似”下一页”之类的链接起的就是这种推进状态的作用——指引你如何从当前状态进入下一个可能的状态。3. 总结现在广东XXX版本、XXX等项目中均使用传统的RPC、SOAP方式的Web服务，而移动南方基地XXXX项目的后台， 虽然采用了JSON格式进行交互，但还是属于RPC风格的。本文从资源的定义、获取、表述、关联、状态变迁等角度， 试图快速理解RESTful架构背后的概念。RESTful架构与传统的RPC、SOAP等方式在理念上有很大的不同，希望本文能对各位理解REST有所帮助。&nbsp;","categories":[{"name":"RESTful","slug":"RESTful","permalink":"http://easybhu.cn/categories/RESTful/"}],"tags":[{"name":"RESTful","slug":"RESTful","permalink":"http://easybhu.cn/tags/RESTful/"}]},{"title":"Principles of good RESTful API Design","slug":"Principles of good RESTful API Design","date":"2020-02-02T09:17:59.000Z","updated":"2020-02-02T09:22:51.982Z","comments":true,"path":"2020/02/02/Principles of good RESTful API Design/","link":"","permalink":"http://easybhu.cn/2020/02/02/Principles%20of%20good%20RESTful%20API%20Design/","excerpt":"","text":"Please Write ArticleGood restful API design is hard! An API represents a contract between you and those who Consume your data. Breaking this contract will result in many angry emails, and a slew of sad users with mobile apps which no longer work. Documentation is half the battle, and it is very difficult to find programmer who also likes to write.Building an API is one of the most important things you can do to increase the value of your service. By having an API, your service / core application has the potential to become a platform from which other services grow. Look at the current huge tech companies: Facebook, Twitter, Google, GitHub, Amazon, Netflix… None of them would be nearly as big as they are today if they hadn’t opened up their data via API. In fact, an entire industry exists with the sole purpose of consuming data provided by said platforms.The easier your API is to consume, the more people that will consume it.The principles of this document, if followed closely when designing your API, will ensure that Consumers of your API will be able to understand what is going on, and should drastically reduce the number of confused and/or angry emails you receive. I’ve organized everything into topics, which don’t necessarily need to be read in order.RESTful API Design DefinitionsHere’s a few of the important terms I will use throughout the course of this document:Resource: A single instance of an object. For example, an animal.Collection: A collection of homogeneous objects. For example, animals.HTTP: A protocol for communicating over a network.Consumer: A client computer application capable of making HTTP requests.Third Party Developer: A developer not a part of your project but who wishes to consume your data.Server: An HTTP server/application accessible from a Consumer over a network.Endpoint: An API URL on a Server which represents either a Resource or an entire Collection.Idempotent: Side-effect free, can happen multiple times without penalty.URL Segment: A slash-separated piece of information in the URL.","categories":[{"name":"RESTful","slug":"RESTful","permalink":"http://easybhu.cn/categories/RESTful/"}],"tags":[{"name":"RESTful","slug":"RESTful","permalink":"http://easybhu.cn/tags/RESTful/"}]},{"title":"WINDOWS 开源 ASP.NET CORE","slug":"WINDOWS 开源 ASP.NET CORE","date":"2020-02-02T09:17:59.000Z","updated":"2020-02-02T09:25:48.074Z","comments":true,"path":"2020/02/02/WINDOWS 开源 ASP.NET CORE/","link":"","permalink":"http://easybhu.cn/2020/02/02/WINDOWS%20%E5%BC%80%E6%BA%90%20ASP.NET%20CORE/","excerpt":"","text":".NET Core Guide.NET Core&nbsp;is an&nbsp;open-source&nbsp;general-purpose development platform maintained by Microsoft and the .NET community on&nbsp;GitHub. It’s cross-platform, supporting Windows, macOS and Linux, and can be used in device, cloud, and IoT applications.See&nbsp;About .NET Core&nbsp;to learn more about .NET Core, including its characteristics, supported languages and frameworks, and key APIs.Check out&nbsp;.NET Core Tutorials&nbsp;to learn how to create a simple .NET Core application. It only takes a few minutes to get your first app up and running. If you want to try .NET Core in you browser, look at the&nbsp;Numbers in C#&nbsp;quickstart.Download .NET Core 2.1Download the&nbsp;.NET Core 2.1 SDK&nbsp;to try .NET Core on your Windows, macOS, or Linux machine. Visit&nbsp;microsoft/dotnet&nbsp;if you prefer to use Docker containers.All .NET Core versions are available at&nbsp;.NET Core Downloads&nbsp;if you’re looking for another .NET Core version..NET Core 2.1The latest version is&nbsp;.NET Core 2.1. New features include: global tools, high-performance APIs (such as&nbsp;System.Span&lt;T&gt;), tiered JIT compilation,&nbsp;build&nbsp;and&nbsp;runtime performance improvements, and support for Alpine and ARM32.Create your first applicationAfter installing the .NET Core SDK, open a command prompt. Type the following&nbsp;dotnetcommands to create and run a C# application.consoledotnet new console dotnet run You should see the following output:consoleHello World! Support.NET Core is&nbsp;supported by Microsoft, on Windows, macOS and Linux. It’s updated for security and quality several times a year, typically monthly..NET Core binary distributions are built and tested on Microsoft-maintained servers in Azure and supported just like any Microsoft product.Red Hat supports .NET Core&nbsp;on Red Hat Enterprise Linux (RHEL). Red Hat builds .NET Core from source and makes it available in the&nbsp;Red Hat Software Collections. Red Hat and Microsoft collaborate to ensure that .NET Core works well on RHEL.","categories":[{"name":"Windows","slug":"Windows","permalink":"http://easybhu.cn/categories/Windows/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://easybhu.cn/tags/Windows/"}]},{"title":"go map详细使用方法","slug":"go map详细使用方法","date":"2020-02-02T09:17:59.000Z","updated":"2020-02-02T09:19:58.147Z","comments":true,"path":"2020/02/02/go map详细使用方法/","link":"","permalink":"http://easybhu.cn/2020/02/02/go%20map%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"Plea现在基本上所有的编程语言都有自带的map，或者dict，主要提供一个快速的查找，插入，删除，具备与存储体量无关的O（1）的性能，并且支持key上面的唯一性，比如java里的HashMap，python里的Dictionary，scala里的各种Map等等。go也原生提供了一个类似的数据类型，就叫做map。首先它是个mutable的，也就是说，可以随时对其进行修改。其次，它不是线程安全的。所以等价于java里的HashMap。申明和初始化map[KeyType]ValueType 这里的KeyType代表map的key类型，一定要是 comparable 的，而ValueType可以是任意的类型，甚至包括其他的内嵌的map比如var m map[string]int这里的keyType是string，valueType就是intmap在go里是属于reference type，也就是作为方法的型参或者返回类型的是时候，传递也是这个reference的地址。不是map的本体。其次，这个map在申明的时候是nil map，需要如果没有初始化，那么就是nil对于这个nil的map，可以对其进行任意的取值，返回都是（nil，err），但是如果对其设置一个新的值，就会panicA nil map behaves like an empty map when reading, but attempts to write to a nil map will cause a runtime panic; don’t do that所以需要先初始化，方法1:m = make(map[string]int) 方法二：var m map[string]int = map[string]int{\"hunter\":12,\"tony\":10} 或者初始化一个空的mapm = map[string]int{} 读取i := m[\"route\"] 如果route存在，就返回那个值，如果不存在，返回0值，也就是说，根据这个value的类型，返回缺省值，比如string，就返回“”，int 就返回0删除delete(m,\"route\") 如果route存在，删除成功，否则什么都没有发生因为读取在不存在key的时候返回0值，为了区分是否成功，可以采用如下手段i, ok := m[\"route\"] 遍历for key, value := range m { fmt.Println(\"Key:\", key, \"Value:\", value) } 稍微高级点的用法利用0值，因为当从map中读取一个不存在的key的时候，返回0值，有时候很麻烦，有时候也可以很巧妙的利用起来，参考原文英文中的例子type Node struct { Next *Node Value interface{} } var first *Node func main(){visited := make(map[*Node]bool) for n := first; n != nil; n = n.Next { if visited[n] { fmt.Println(“cycle detected”) break } visited[n] = true fmt.Println(n.Value) }} 这是一个检测单向链表是否有环的比较笨的办法，原理就是利用map判断这个key为＊Node的值在map中是否出现过来确定是否有环。这里的visited就是map，从这里我们可以看到，指针类型也是comparable的，所以可以作为keytype，其次，调用if语句中的visited［n］的时候，我们巧妙的利用了bool类型的0值就是false这个原理，来判断这个keytype是否已经出现。还是原文中的例子：type Person struct { Name string Likes []string } var people []*Person likes := make(map[string][]*Person) for _, p := range people { for _, l := range p.Likes { likes[l] = append(likes[l], p) } } for _, p := range likes[&quot;cheese&quot;] { fmt.Println(p.Name, &quot;likes cheese.&quot;) }我们有一个自定义的struct，Person，里面存了人的名字和他／她的爱好，现在我们要写一个简单的小程序，把所有的people（人员）按照相同兴趣进行分类我们这里的代码就是利用两个go里的特征，1, range对于非nil的map，可以进行遍历，但是如果是nil的map（也就是没有初始化的map），默认按照空的map处理，也就是不运行for循环的逻辑代码2, append支持非nil和nil 的map，都能进行成功的append。这样，就能简化代码刚才提到map里的keytype必须是comparable的，go的文档里有明确的定义：The language spec defines this precisely, but in short, comparable types are boolean, numeric, string, pointer, channel, and interface types, and structs or arrays that contain only those types.Notably absent from the list are slices, maps, and functions;these types cannot be compared using ==, and may not be used as map keys.线程安全（goroutine）前面提到go的map不是线程安全的，因此需要加锁，一般的方法是，定义一个embeded的struct，类似于子类var counter = struct{ sync.RWMutex m map[string]int}{m: make(map[string]int)}读的时候，调用读锁counter.RLock()n := counter.m[\"some_key\"]counter.RUnlock()fmt.Println(\"some_key:\", n)写的时候，写锁counter.Lock()counter.m[\"some_key\"]++counter.Unlock()＃ 读取顺序go的map是hashmap，所以读取遍历的顺序是不保证的，如果业务需要保证key的遍历顺序，建议将key单独保存到一个slice里import \"sort\" var m map[int]stringvar keys []intfor k := range m { keys = append(keys, k)}sort.Ints(keys)for _, k := range keys { fmt.Println(\"Key:\", k, \"Value:\", m[k])}链接：https://www.jianshu.com/p/ba7852fbcc80","categories":[{"name":"GoLang","slug":"GoLang","permalink":"http://easybhu.cn/categories/GoLang/"}],"tags":[{"name":"GoLang","slug":"GoLang","permalink":"http://easybhu.cn/tags/GoLang/"}]},{"title":"初学goLang搭建WEB服务","slug":"初学goLang搭建WEB服务","date":"2020-02-02T09:17:59.000Z","updated":"2020-02-02T09:25:02.103Z","comments":true,"path":"2020/02/02/初学goLang搭建WEB服务/","link":"","permalink":"http://easybhu.cn/2020/02/02/%E5%88%9D%E5%AD%A6goLang%E6%90%AD%E5%BB%BAWEB%E6%9C%8D%E5%8A%A1/","excerpt":"","text":"package mainimport ( \"fmt\" \"net/http\" \"strings\" \"log\")func sayhelloName(w http.ResponseWriter, r *http.Request) { r.ParseForm() //解析参数，默认是不会解析的 fmt.Println(r.Form) //这些信息是输出到服务器端的打印信息 fmt.Println(\"path\", r.URL.Path) fmt.Println(\"scheme\", r.URL.Scheme) fmt.Println(r.Form[\"url_long\"]) for k, v := range r.Form { fmt.Println(\"key:\", k) fmt.Println(\"val:\", strings.Join(v, \"\")) } fmt.Fprintf(w, \"Hello!\") //这个写入到w的是输出到客户端的}func main() { http.HandleFunc(\"/\", sayhelloName) //设置访问的路由 err := http.ListenAndServe(\":9090\", nil) //设置监听的端口 if err != nil { log.Fatal(\"ListenAndServe: \", err); }}","categories":[{"name":"GoLang","slug":"GoLang","permalink":"http://easybhu.cn/categories/GoLang/"}],"tags":[{"name":"GoLang","slug":"GoLang","permalink":"http://easybhu.cn/tags/GoLang/"}]},{"title":"网页头部的声明应该是用 lang=”zh” 还是 lang=”zh-cn”？","slug":"网页头部的声明应该是用 lang=”zh” 还是 lang=”zh-cn”？","date":"2020-02-02T09:17:59.000Z","updated":"2020-02-02T09:25:48.069Z","comments":true,"path":"2020/02/02/网页头部的声明应该是用 lang=”zh” 还是 lang=”zh-cn”？/","link":"","permalink":"http://easybhu.cn/2020/02/02/%E7%BD%91%E9%A1%B5%E5%A4%B4%E9%83%A8%E7%9A%84%E5%A3%B0%E6%98%8E%E5%BA%94%E8%AF%A5%E6%98%AF%E7%94%A8%20lang=%E2%80%9Dzh%E2%80%9D%20%E8%BF%98%E6%98%AF%20lang=%E2%80%9Dzh-cn%E2%80%9D%EF%BC%9F/","excerpt":"","text":"Ple“zh”是中文，代表的是宏语言（Macrolanguage），单独使用表示“中文”整体，可以是方言、文言文、简体、繁体等单独一种，也可以是任意组合的混合内容。“zh-CN”理论上表示的是“中文 (中国大陆)”，因为中国大陆的官方语言是“普通话 (简体)”，所以这个“zh”的局限性就体现出来了：比如“尋尋覓覓，冷冷清清，悽悽慘慘戚戚”，用“zh-CN”描述没法表达出“繁體”和“文言文”，但描述成“zh-TW”则成了“中文 (繁體, 台灣)”，虽然指明了“繁体”，但还是没能体现出“文言文”，同时还丢失了“中国大陆”。针对这种情况，按照 BCP 47 规范 (详见参考链接 2)，应该使用独立语种更精确地描述：cmn 普通话（官话、国语） wuu 吴语（江浙话、上海话） czh 徽语（徽州话、严州话、吴语-徽严片） hak 客家语 yue 粤语（广东话） nan 闽南语（福建话、台语） cpx 莆仙话（莆田话、兴化语） cdo 闽东语 mnp 闽北语 zco 闽中语 gan 赣语（江西话） hsn 湘语（湖南话） cjy 晋语（山西话、陕北话）语言文字标签书写顺序：language-extlang-script-region-variant-extension-privateuse 语言文字种类-扩展语言文字种类-书写格式-国家和地区-变体-扩展-私有 语言文字标签示例：language: fr 法语 es 西班牙语 language-extlang:zh-lzh 中文 (文言文)sgn-csl 手语 (中国大陆) language-script:cmn-Hans 普通话 (简体)yue-Hant 粤语 (繁体) language-region:zh-CN 中文 (简体, 中国大陆)en-US 英语 (美国) language-script-region：cmn-Hans-CN 普通话 (简体, 中国大陆)cmn-Hant-TW 普通话 (繁体, 台湾) language-script-variant:zh-Latn-pinyin 汉语拼音（例：nǐ，拉丁字母形式）zh-Bopo-pinyin 注音拼音（例：ㄋ丨ˇ，罗马字形式，中国大陆 1958 年以前使用，台湾目前使用） 常见的一般有 language、language-script 和 language-region 三种。附注 1：“cmn”“wuu”“yue”等 2005 年确定的 extlang 标记已于 2009 年提升为 language 标记，维基百科中“吴语”“粤语”等页面均已使用最新的标准写法，以下以“zh”开头的写法已被废弃并不再推荐使用 (详见参考链接 3)，请直接去掉“zh-”前缀并使用“cmn”“wuu”“yue”等代替即可：zh-Hans, zh-Hans-CN, zh-cmn, zh-cmn-Hans, zh-wuu, zh-yue, zh-gan....类似还有 zh-Hans-HK、zh-Hans-MO、zh-Hans-TW、zh-Hant废弃可能原因：在语言学的分类上，中国语言学者多认为“吴语”“粤语”“闽语”等是“汉语”的方言，而西方学者多认为这些语言是一门和“普通话”同级关系的单独语种。中国大陆常见划分：1. 汉藏语系 1.1. 汉语族 1.1.1. 汉语 1.2. 藏缅语族 1.3. 苗瑶语族 1.4. 壮侗语族 “汉语族”仅包含“汉语”一门语言，“吴语”“客家语”“粤语”“闽语”等均归属于“汉语”的不同方言。西方常见划分：1. 汉藏语系 1.1. 汉语族 1.1.1. 普通话（官话、国语） 1.1.2. 吴语（江浙话、上海话） 1.1.3. 徽语（徽州话、严州话、吴语-徽严片） 1.1.4. 客家语 1.1.5. 粤语（广东话） 1.1.6. 闽南语（福建话、台语） 1.1.7. 莆仙话（莆田话、兴化语） 1.1.8. 闽东语 1.1.9. 闽北语 1.1.10. 闽中语 1.1.11. 赣语（江西话） 1.1.12. 湘语（湖南话） 1.1.13. 晋语（山西话、陕北话） 1.2. 藏缅语族 1.3. 苗瑶语族 1.4. 壮侗语族 “汉语族”包含“普通话”“吴语”“徽语”“客家话”“粤语”等多种语言。重点来了！以下两种写法均正确，后者描述更精准，但大部分程序和操作系统都只能识别前者，使用新标准可能会造成无法匹配浏览器用户定义字体、网页翻译、程序语言自动切换等功能，为了兼容性的考量，推荐使用前者：zh-CN 中文 (简体, 中国大陆) 对应 cmn-Hans-CN 普通话 (简体, 中国大陆)zh-SG 中文 (简体, 新加坡) 对应 cmn-Hans-SG 普通话 (简体, 新加坡)zh-HK 中文 (繁体, 香港) 对应 yue-Hant-HK 粤语 (繁体, 香港)zh-MO 中文 (繁体, 澳门) 对应 yue-Hant-MO 粤语 (繁体, 澳门)zh-TW 中文 (繁体, 台湾) 对应 cmn-Hant-TW 普通话 (繁体, 台湾)附注 2：同是简体中文页面， 默认或书面语均标记为“cmn (普通话)”，全文使用地方方言表达时，使用相应语言文字标签标记，例：“你” “我们” 用 cmn-Hans 普通话 (简体)“侬” “啊啦” 用 wuu-Hans 吴语 (简体)“你” “我哋” 用 yue-Hans 粤语 (简体)一般情况不用 region 选项，但如果要针对特定地区特定用语的友好性，则应设置区域，例 ：“消息” “黄梨” “自行车” 用 cmn-Hans-SG 普通话 (简体, 新加坡)“消息” “菠萝” “自行车” 用 cmn-Hans-CN 普通话 (简体, 中国大陆)“消息” “菠蘿” “自行車” 用 cmn-Hant-CN 普通话 (繁体, 中国大陆)“訊息” “菠蘿” “单车” 用 cmn-Hant-HK 普通话 (繁体, 香港)“訊息” “鳳梨” “腳踏車” 用 cmn-Hant-TW 普通话 (繁体, 台湾) “analyse” “color” “elevator” 用 en-US 英语 (美国)“analyze” “colour” “lift” 用 en-GB 英语 (英国)原文链接：https://www.zhihu.com/question/20797118/answer/63480740","categories":[{"name":"Html","slug":"Html","permalink":"http://easybhu.cn/categories/Html/"}],"tags":[{"name":"Html","slug":"Html","permalink":"http://easybhu.cn/tags/Html/"}]},{"title":"Hexo 博客快速建立及部署","slug":"hello-world","date":"2020-02-01T16:00:00.000Z","updated":"2020-02-02T08:41:49.890Z","comments":true,"path":"2020/02/02/hello-world/","link":"","permalink":"http://easybhu.cn/2020/02/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[{"name":"hexo","slug":"hexo","permalink":"http://easybhu.cn/categories/hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://easybhu.cn/tags/Hexo/"},{"name":"Blog","slug":"Blog","permalink":"http://easybhu.cn/tags/Blog/"}]}]}