<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>软件开发版本各阶段</title>
      <link href="/2020/04/09/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%89%88%E6%9C%AC%E5%90%84%E9%98%B6%E6%AE%B5/"/>
      <url>/2020/04/09/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%89%88%E6%9C%AC%E5%90%84%E9%98%B6%E6%AE%B5/</url>
      
        <content type="html"><![CDATA[<div><p><strong><span style="color:#cc6600;">软件版本周期</span></strong></p><p>α、β、λ 常用来表示软件测试过程中的三个阶段。</p><p>-- α 是第一阶段，一般只供内部测试使用；<br></p><p>--&nbsp;β是第二个阶段，已经消除了软件中大部分的不完善之处，但仍有可能还存在缺陷和漏洞，一般只提供给特定的用户群来测试使用；</p><p>--&nbsp;λ是第三个阶段，此时产品已经相当成熟，只需在个别地方再做进一步的优化处理即可上市发行。</p><p><br></p><p><strong><span style="color:#cc6600;">开发期</span></strong></p><p><strong>--</strong><span style="color:#ff0000;font-weight:bold;"> Alpha</span>(α)：<span style="color:#ff0000;"><strong>预览版</strong></span>，或者叫内部测试版；一般不向外部发布，会有很多Bug；一般只有测试人员使用。</p><p><strong>--<span style="color:#ff0000;"> Beta</span></strong>(β)：<strong><span style="color:#ff0000;">测试版</span></strong>，或者叫公开测试版；这个阶段的版本会一直加入新的功能；在 Alpha版之后推出。<br></p><p><strong>--<span style="color:#ff0000;"> RC</span></strong>(Release Candidate)：<strong><span style="color:#ff0000;">最终测试版本</span></strong>；可能成为最终产品的候选版本，如果未出现问题则可发布成为正式版本</p><p>多数开源软件会推出两个RC版本，最后的 RC2 则成为正式版本。<br></p><p><br></p><p><strong><span style="color:#cc6600;">完成期</span></strong></p><p>-- <strong><span style="color:#ff0000;">Stable</span></strong>：<strong><span style="color:#ff0000;">稳定版</span></strong>；来自预览版本释出使用与改善而修正完成。<br></p><p>-- <strong><span style="color:#ff0000;">GA</span></strong>(General Availability)：正式发布的版本；在国外都是用GA来说明<strong><span style="color:#ff0000;">release版本</span></strong>的。<br></p><p>-- <span style="color:#ff0000;"><strong>RTM</strong></span>(Release to Manufacturing)：给生产商的<span style="color:#ff0000;"><strong>release版本</strong></span>；RTM版本并不一定意味着创作者解决了软件所有问题；仍有可能向公众发布前更新版本。<br></p><p>另外一种RTM的称呼是<span style="color:#ff0000;"><strong>RTW</strong></span>（Release To Web），表示正式版本的软件发布到Web网站上供客户免费下载。<br></p><p>-- <strong><span style="color:#ff0000;">RTL</span></strong>(Retail)：<strong><span style="color:#ff0000;">零售版</span></strong>；是真正的正式版，正式上架零售版。<br></p><p>以Windows 7为例，RTM版与零售版的版本号是一样的。</p><p><br></p><p><strong><span style="color:#cc6600;">其他表述</span></strong></p><p>-- <strong><span style="color:#ff0000;">OEM</span></strong>(Original Equipment Manufacturer)：原始设备制造商；是给计算机厂商随着计算机贩卖的，也就是<strong><span style="color:#ff0000;">随机版</span></strong>；</p><p>只能随机器出货，不能零售。只能全新安装，不能从旧有操作系统升级。包装不像零售版精美，通常只有一面CD和说明书(授权书)。</p><p>-- RVL：号称是正式版，其实RVL根本不是版本的名称。它是中文版/英文版文档破解出来的。<br></p><p>-- EVAL：而流通在网络上的EVAL版，与“评估版”类似，功能上和零售版没有区别。<br></p><p><br></p>]]></content>
      
      
      <categories>
          
          <category> Version </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Version </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php 获取本周开始日期和结束日期的方法</title>
      <link href="/2020/02/02/php-%E8%8E%B7%E5%8F%96%E6%9C%AC%E5%91%A8%E5%BC%80%E5%A7%8B%E6%97%A5%E6%9C%9F%E5%92%8C%E7%BB%93%E6%9D%9F%E6%97%A5%E6%9C%9F%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2020/02/02/php-%E8%8E%B7%E5%8F%96%E6%9C%AC%E5%91%A8%E5%BC%80%E5%A7%8B%E6%97%A5%E6%9C%9F%E5%92%8C%E7%BB%93%E6%9D%9F%E6%97%A5%E6%9C%9F%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<pre><code>// 当前日期$sdefaultDate = date("Y-m-d");// $first =1 表示每周星期一为开始日期 0表示每周日为开始日期$first=1;// 获取当前周的第几天 周日是0 周一到周六是 1 - 6$w = date('w', strtotime($sdefaultDate));// 获取本周开始日期，如果$w是0，则表示周日，减去 6 天$week_start=date('Y-m-d', strtotime("$sdefaultDate -".($w ? $w - $first : 6).' days'));// 本周结束日期$week_end=date('Y-m-d',strtotime("$week_start +6 days"));echo "$week_start"."$week_end";</code></pre>]]></content>
      
      
      <categories>
          
          <category> Php </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL查看数据库表容量大小</title>
      <link href="/2020/02/02/MySQL%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E5%AE%B9%E9%87%8F%E5%A4%A7%E5%B0%8F/"/>
      <url>/2020/02/02/MySQL%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E5%AE%B9%E9%87%8F%E5%A4%A7%E5%B0%8F/</url>
      
        <content type="html"><![CDATA[<p>【https://blog.csdn.net/fdipzone/article/details/80144166】</p><h3 id="1查看所有数据库容量大小">1.查看所有数据库容量大小</h3><div><div><div id="highlighter_271702"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div></td><td><div><div><code>select</code></div><div><code>table_schema&nbsp;</code><code>as</code>&nbsp;<code>'数据库'</code><code>,</code></div><div><code>sum(table_rows)&nbsp;</code><code>as</code>&nbsp;<code>'记录数'</code><code>,</code></div><div><code>sum(truncate(data_length/1024/1024, 2))&nbsp;</code><code>as</code>&nbsp;<code>'数据容量(MB)'</code><code>,</code></div><div><code>sum(truncate(index_length/1024/1024, 2))&nbsp;</code><code>as</code>&nbsp;<code>'索引容量(MB)'</code></div><div><code>from</code>&nbsp;<code>information_schema.tables</code></div><div><code>group</code>&nbsp;<code>by</code>&nbsp;<code>table_schema</code></div><div><code>order&nbsp;</code><code>by</code>&nbsp;<code>sum(data_length) desc, sum(index_length) desc;</code></div></div></td></tr></tbody></table></div></div></div><p>　　</p><h3 id="2查看所有数据库各表容量大小"><a name="t1"></a>2.查看所有数据库各表容量大小</h3><div><div><div id="highlighter_368250"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div></td><td><div><div><code>select</code></div><div><code>table_schema&nbsp;</code><code>as</code>&nbsp;<code>'数据库'</code><code>,</code></div><div><code>table_name&nbsp;</code><code>as</code>&nbsp;<code>'表名'</code><code>,</code></div><div><code>table_rows&nbsp;</code><code>as</code>&nbsp;<code>'记录数'</code><code>,</code></div><div><code>truncate(data_length/1024/1024, 2)&nbsp;</code><code>as</code>&nbsp;<code>'数据容量(MB)'</code><code>,</code></div><div><code>truncate(index_length/1024/1024, 2)&nbsp;</code><code>as</code>&nbsp;<code>'索引容量(MB)'</code></div><div><code>from</code>&nbsp;<code>information_schema.tables</code></div><div><code>order&nbsp;</code><code>by</code>&nbsp;<code>data_length desc, index_length desc;</code></div></div></td></tr></tbody></table></div></div></div><p>　　</p><h3 id="3查看指定数据库容量大小"><a name="t2"></a>3.查看指定数据库容量大小</h3><p>例：查看mysql库容量大小</p><div><div><div id="highlighter_884986"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div></td><td><div><div><code>select</code></div><div><code>table_schema&nbsp;</code><code>as</code>&nbsp;<code>'数据库'</code><code>,</code></div><div><code>sum(table_rows)&nbsp;</code><code>as</code>&nbsp;<code>'记录数'</code><code>,</code></div><div><code>sum(truncate(data_length/1024/1024, 2))&nbsp;</code><code>as</code>&nbsp;<code>'数据容量(MB)'</code><code>,</code></div><div><code>sum(truncate(index_length/1024/1024, 2))&nbsp;</code><code>as</code>&nbsp;<code>'索引容量(MB)'</code></div><div><code>from</code>&nbsp;<code>information_schema.tables</code></div><div><code>where</code>&nbsp;<code>table_schema=</code><code>'mysql'</code><code>;</code></div></div></td></tr></tbody></table></div></div></div><p>　　</p><h3 id="4查看指定数据库各表容量大小"><a name="t3"></a>4.查看指定数据库各表容量大小</h3><p>例：查看mysql库各表容量大小</p><div><div><div id="highlighter_775604"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div></td><td><div><div><code>select</code></div><div><code>table_schema&nbsp;</code><code>as</code>&nbsp;<code>'数据库'</code><code>,</code></div><div><code>table_name&nbsp;</code><code>as</code>&nbsp;<code>'表名'</code><code>,</code></div><div><code>table_rows&nbsp;</code><code>as</code>&nbsp;<code>'记录数'</code><code>,</code></div><div><code>truncate(data_length/1024/1024, 2)&nbsp;</code><code>as</code>&nbsp;<code>'数据容量(MB)'</code><code>,</code></div><div><code>truncate(index_length/1024/1024, 2)&nbsp;</code><code>as</code>&nbsp;<code>'索引容量(MB)'</code></div><div><code>from</code>&nbsp;<code>information_schema.tables</code></div><div><code>where</code>&nbsp;<code>table_schema=</code><code>'mysql'</code></div><div><code>order&nbsp;</code><code>by</code>&nbsp;<code>data_length desc, index_length desc;</code></div></div></td></tr></tbody></table></div></div></div><p>&nbsp;</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql json使用类型查询函数</title>
      <link href="/2020/02/02/mysql-json%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%9F%A5%E8%AF%A2%E5%87%BD%E6%95%B0/"/>
      <url>/2020/02/02/mysql-json%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%9F%A5%E8%AF%A2%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1>一,对记录的操作</h1><p>1.创建有json字段的表</p><div><pre>-- 创建表<pre><code>CREATE TABLE t_json(id INT PRIMARY KEY, sname VARCHAR(20) , info  JSON);</code></pre></pre></div><p>2.插入记录</p><div><pre>-- 插入含有json数组的记录<pre><code>INSERT INTO t_json(id,sname,info) VALUES( 1, 'name1', JSON_ARRAY(1, "abc", NULL, TRUE, CURTIME()));</code></pre>-- 插入含有json对象的记录<br></pre><div><pre><code>INSERT INTO t_json(id,sname,info) VALUES( 2, 'name2', JSON_OBJECT("age", 20, "time", now()));<br>INSERT INTO t_json(id,sname,info) VALUES( 3, 'name3', '{"age":20, "time":"2018-07-14 10:52:00"}');</code></pre></div></div><p>3.查询记录</p><div><pre>-- 查询记录<pre><code>SELECT sname,JSON_EXTRACT(info,'$.age') FROM t_json;<br>SELECT sname,info-&gt;'$.age' FROM t_json;</code></pre>-- 查询key<pre><code>SELECT id,json_keys(info) FROM t_json;</code></pre></pre></div><p>4.修改记录</p><div><pre>-- 增加键<pre><code>UPDATE t_json SET info = json_set(info,'$.ip','192.168.1.1') WHERE id = 2;</code></pre>-- 变更值<pre><code>UPDATE t_json SET info = json_set(info,'$.ip','192.168.1.2') WHERE id = 2;</code></pre>-- 删除键<pre><code>UPDATE t_json SET info = json_remove(info,'$.ip') WHERE id = 2;</code></pre></pre><div><br></div></div><h1>二,创建json值函数</h1><p>1.JSON_ARRAY 生成json数组</p><div><pre>-- JSON_ARRAY(val1,val2,val3...)-- 生成一个包含指定元素的json数组。<pre><code>SELECT JSON_ARRAY(1, "abc", NULL, TRUE, CURTIME()); -- [1, "abc", null, true, "10:37:08.000000"]</code></pre></pre></div><p>2.JSON_OBJECT 生成json对象</p><div><pre>-- JSON_OBJECT(key1,val1,key2,val2...)-- 生成一个包含指定K-V对的json object。如果有key为NULL或参数个数为奇数，则抛错。<pre><code>SELECT JSON_OBJECT('age', 20, 'time', now()); -- {"id": 87, "name": "carrot"}</code></pre></pre></div><p>3.JSON_QUOTE 加"号</p><div><pre>-- JSON_QUOTE(json_val)-- 将json_val用"号括起来。<pre><code>SELECT JSON_QUOTE('[1,2,3]'); -- "[1,2,3]"</code></pre></pre></div><h1>三,搜索json值函数</h1><p>1.JSON_CONTAINS 指定数据是否存在</p><div><pre>set @j = '{"a": 1, "b": 2, "c": {"d": 4}}';-- JSON_CONTAINS(json_doc, val[, path])-- 查询json文档是否在指定path包含指定的数据，包含则返回1，否则返回0。如果有参数为NULL或path不存在，则返回NULL。<pre><code>SELECT JSON_CONTAINS(@j, '4', '$.c.d'); -- 1</code></pre></pre></div><p>2.JSON_CONTAINS_PATH 指定路径是否存在</p><div><pre>-- JSON_CONTAINS_PATH(json_doc, one_or_all, path[, path] ...)-- 查询是否存在指定路径，存在则返回1，否则返回0。如果有参数为NULL，则返回NULL。-- one_or_all只能取值"one"或"all"，one表示只要有一个存在即可；all表示所有的都存在才行。<pre><code>SELECT JSON_CONTAINS_PATH(@j, 'one', '$.a', '$.e'); -- 1<br>SELECT JSON_CONTAINS_PATH(@j, 'all', '$.a', '$.c.d'); -- 1</code></pre></pre></div><p>3.JSON_EXTRACT 查找所有指定数据</p><div><pre>-- JSON_EXTRACT(json_doc, path[, path] ...)-- 从json文档里抽取数据。如果有参数有NULL或path不存在，则返回NULL。如果抽取出多个path，则返回的数据封闭在一个json array里。<pre><code>set @j2 = '[10, 20, [30, 40]]';<br>SELECT JSON_EXTRACT('[10, 20, [30, 40]]', '$[1]'); -- 20<br>SELECT JSON_EXTRACT('[10, 20, [30, 40]]', '$[1]', '$[0]'); -- [20, 10]<br>SELECT JSON_EXTRACT('[10, 20, [30, 40]]', '$[2][*]'); -- [30, 40]</code></pre></pre></div><p>4.JSON_KEYS 查找所有指定键值</p><div><pre>-- JSON_KEYS(json_doc[, path])-- 获取json文档在指定路径下的所有键值，返回一个json array。如果有参数为NULL或path不存在，则返回NULL。<pre><code>SELECT JSON_KEYS('{"a": 1, "b": {"c": 30}}'); -- ["a", "b"]<br>SELECT JSON_KEYS('{"a": 1, "b": {"c": 30}}', '$.b'); -- ["c"]<br>SELECT id,json_keys(info) FROM t_json;</code></pre></pre></div><p>5.JSON_SEARCH 查找所有指定值的位置</p><div><pre>-- JSON_SEARCH(json_doc, one_or_all, search_str[, escape_char[, path] ...])-- 查询包含指定字符串的paths，并作为一个json array返回。如果有参数为NUL或path不存在，则返回NULL。-- one_or_all："one"表示查询到一个即返回；"all"表示查询所有。-- search_str：要查询的字符串。 可以用LIKE里的'%'或‘_’匹配。-- path：在指定path下查。<pre><code>SET @j3 = '["abc", [{"k": "10"}, "def"], {"x":"abc"}, {"y":"bcd"}]';<br>SELECT JSON_SEARCH(@j3, 'one', 'abc'); -- "$[0]"<br>SELECT JSON_SEARCH(@j3, 'all', 'abc'); -- ["$[0]", "$[2].x"]<br>SELECT JSON_SEARCH(@j3, 'all', 'abc', NULL, '$[2]'); -- "$[2].x"<br>SELECT JSON_SEARCH(@j3, 'all', '10'); -- "$[1][0].k"<br>SELECT JSON_SEARCH(@j3, 'all', '%b%'); -- ["$[0]", "$[2].x", "$[3].y"]<br>SELECT JSON_SEARCH(@j3, 'all', '%b%', NULL, '$[2]'); -- "$[2].x"</code></pre></pre></div><h1>四,修改json值函数</h1><p>1.JSON_ARRAY_APPEND&nbsp; 指定位置追加数组元素</p><div><div><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></div><pre>-- JSON_ARRAY_APPEND(json_doc, path, val[, path, val] ...)-- 在指定path的json array尾部追加val。如果指定path是一个json object，则将其封装成一个json array再追加。如果有参数为NULL，则返回NULL。SET @j4 = '["a", ["b", "c"], "d"]';-- SELECT JSON_ARRAY_APPEND(@j4, '$[1][0]', 3); -- ["a", [["b", 3], "c"], "d"]<pre><code>SET @j5 = '{"a": 1, "b": [2, 3], "c": 4}';<br>SELECT JSON_ARRAY_APPEND(@j5, '$.b', 'x'); -- {"a": 1, "b": [2, 3, "x"], "c": 4} <br>SELECT JSON_ARRAY_APPEND(@j5, '$.c', 'y'); -- {"a": 1, "b": [2, 3], "c": [4, "y"]}<br>SELECT JSON_ARRAY_APPEND(@j5, '$', 'z'); -- [{"a": 1, "b": [2, 3], "c": 4}, "z"]</code></pre></pre></div><p>2.JSON_ARRAY_INSERT 指定位置插入数组元素</p><div><pre>-- JSON_ARRAY_INSERT(json_doc, path, val[, path, val] ...)-- 在path指定的json array元素插入val，原位置及以右的元素顺次右移。如果path指定的数据非json array元素，则略过此val；如果指定的元素下标超过json array的长度，则插入尾部。<pre><code>SET @j6 = '["a", {"b": [1, 2]}, [3, 4]]';<br>SELECT JSON_ARRAY_INSERT(@j6, '$[1]', 'x'); -- ["a", "x", {"b": [1, 2]}, [3, 4]]<br>SELECT JSON_ARRAY_INSERT(@j6, '$[100]', 'x'); -- ["a", {"b": [1, 2]}, [3, 4], "x"]<br>SELECT JSON_ARRAY_INSERT(@j6, '$[1].b[0]', 'x'); -- ["a", {"b": ["x", 1, 2]}, [3, 4]]<br>SELECT JSON_ARRAY_INSERT(@j6, '$[0]', 'x', '$[3][1]', 'y'); -- ["x", "a", {"b": [1, 2]}, [3, "y", 4]]</code></pre></pre></div><p>3.JSON_INSERT 指定位置插入</p><div><pre>-- JSON_INSERT(json_doc, path, val[, path, val] ...)-- 在指定path下插入数据，如果path已存在，则忽略此val（不存在才插入）。<pre><code>SET @j7 = '{ "a": 1, "b": [2, 3]}';<br>SELECT JSON_INSERT(@j7, '$.a', 10, '$.c', '[true, false]'); -- {"a": 1, "b": [2, 3], "c": "[true, false]"}</code></pre></pre></div><p>4.JSON_REPLACE 指定位置替换</p><div><pre>-- JSON_REPLACE(json_doc, path, val[, path, val] ...)-- 替换指定路径的数据，如果某个路径不存在则略过（存在才替换）。如果有参数为NULL，则返回NULL。<pre><code>SELECT JSON_REPLACE(@j7, '$.a', 10, '$.c', '[true, false]'); -- {"a": 10, "b": [2, 3]}</code></pre></pre></div><p>5.JSON_SET 指定位置设置</p><div><pre>-- JSON_SET(json_doc, path, val[, path, val] ...)-- 设置指定路径的数据（不管是否存在）。如果有参数为NULL，则返回NULL。<pre><code>SELECT JSON_SET(@j7, '$.a', 10, '$.c', '[true, false]'); -- {"a": 10, "b": [2, 3], "c": "[true, false]"}</code></pre></pre></div><p>6.JSON_MERGE 合并</p><div><pre>-- JSON_MERGE(json_doc, json_doc[, json_doc] ...)-- merge多个json文档。规则如下：-- 如果都是json array，则结果自动merge为一个json array；-- 如果都是json object，则结果自动merge为一个json object；-- 如果有多种类型，则将非json array的元素封装成json array再按照规则一进行mege。<pre><code>SELECT JSON_MERGE('[1, 2]', '[true, false]'); -- [1, 2, true, false]<br>SELECT JSON_MERGE('{"name": "x"}', '{"id": 47}'); -- {"id": 47, "name": "x"}<br>SELECT JSON_MERGE('1', 'true'); -- [1, true]<br>SELECT JSON_MERGE('[1, 2]', '{"id": 47}'); -- [1, 2, {"id": 47}]</code></pre></pre></div><p>7.JSON_REMOVE 指定位置移除</p><div><pre>-- JSON_REMOVE(json_doc, path[, path] ...)-- 移除指定路径的数据，如果某个路径不存在则略过此路径。如果有参数为NULL，则返回NULL。<pre><code>SET @j8 = '["a", ["b", "c"], "d"]';<br>SELECT JSON_REMOVE(@j8, '$[1]'); -- ["a", "d"]</code></pre></pre></div><p>8.JSON_UNQUOTE 去"号</p><div><pre>-- JSON_UNQUOTE(val)-- 去掉val的引号。如果val为NULL，则返回NULL。<pre><code>SELECT JSON_UNQUOTE("\"123\""); -- 123</code></pre></pre></div><h1>五,返回json值属性的函数</h1><p>1.JSON_DEPTH 深度</p><div><pre>-- JSON_DEPTH(json_doc)-- 获取json文档的深度。如果参数为NULL，则返回NULL。-- 空的json array、json object或标量的深度为1。<pre><code>SELECT JSON_DEPTH('{}'), JSON_DEPTH('[]'), JSON_DEPTH('true'); -- 1 1 1<br>SELECT JSON_DEPTH('[10, 20]'), JSON_DEPTH('[[], {}]'); -- 2 2<br>SELECT JSON_DEPTH('[10, {"a": 20}]'); -- 3</code></pre></pre></div><p>2.JSON_LENGTH 长度</p><div><pre>-- JSON_LENGTH(json_doc[, path])-- 获取指定路径下的长度。如果参数为NULL，则返回NULL。　-- 长度的计算规则：-- 标量的长度为1；-- json array的长度为元素的个数；-- json object的长度为key的个数。<pre><code>SELECT JSON_LENGTH('[1, 2, {"a": 3}]'); -- 3<br>SELECT JSON_LENGTH('{"a": 1, "b": {"c": 30}}'); -- 2<br>SELECT JSON_LENGTH('{"a": 1, "b": {"c": 30}}', '$.b'); -- 1</code></pre></pre></div><p>3.JSON_TYPE 类型</p><div><pre>-- JSON_TYPE(json_val)-- 获取json文档的具体类型。如果参数为NULL，则返回NULL。<pre><code>select JSON_TYPE('[1,2]'); -- ARRAY</code></pre></pre></div><p>4.JSON_VALID 是否有效json格式</p><div><pre>-- JSON_VALID(val)-- 判断val是否为有效的json格式，是为1，不是为0。如果参数为NUL，则返回NULL。<pre><code>SELECT JSON_VALID('{"a": 1}'); -- 1<br>SELECT JSON_VALID('hello'), JSON_VALID('"hello"'); -- 1</code></pre></pre></div><p>附录:</p><div><pre>JSON_ARRAY 生成json数组JSON_OBJECT 生成json对象JSON_QUOTE 加"号JSON_CONTAINS 指定数据是否存在JSON_CONTAINS_PATH 指定路径是否存在JSON_EXTRACT 查找所有指定数据JSON_KEYS 查找所有指定键值JSON_SEARCH 查找所有指定值的位置JSON_ARRAY_APPEND  指定位置追加数组元素JSON_ARRAY_INSERT 指定位置插入数组元素JSON_INSERT 指定位置插入JSON_REPLACE 指定位置替换JSON_SET 指定位置设置JSON_MERGE 合并JSON_REMOVE 指定位置移除JSON_UNQUOTE 去"号JSON_DEPTH 深度JSON_LENGTH 长度JSON_TYPE 类型JSON_VALID 是否有效json格式</pre></div><p>&nbsp;</p><table summary="A reference that lists all JSON functions." frame="box" rules="all"><thead><tr><th scope="col">函数名</th><th scope="col">描述</th></tr></thead><tbody><tr><td scope="row"><a href="https://dev.mysql.com/doc/refman/5.7/en/json-modification-functions.html#function_json-append" target="_blank" rel="noopener"><code>JSON_APPEND()</code></a>（废弃的5.7.9）</td><td>JSON文件追加数据</td></tr><tr><td scope="row"><a href="https://dev.mysql.com/doc/refman/5.7/en/json-creation-functions.html#function_json-array" target="_blank" rel="noopener"><code>JSON_ARRAY()</code></a></td><td>创建JSON数组</td></tr><tr><td scope="row"><a href="https://dev.mysql.com/doc/refman/5.7/en/json-modification-functions.html#function_json-array-append" target="_blank" rel="noopener"><code>JSON_ARRAY_APPEND()</code></a></td><td>JSON文件追加数据</td></tr><tr><td scope="row"><a href="https://dev.mysql.com/doc/refman/5.7/en/json-modification-functions.html#function_json-array-insert" target="_blank" rel="noopener"><code>JSON_ARRAY_INSERT()</code></a></td><td>插入JSON数组</td></tr><tr><td scope="row"><a href="https://dev.mysql.com/doc/refman/5.7/en/json-search-functions.html#operator_json-column-path" target="_blank" rel="noopener"><code>-&gt;</code></a></td><td>在评估路径返回JSON列值；相当于json_extract()。</td></tr><tr><td scope="row"><a href="https://dev.mysql.com/doc/refman/5.7/en/json-search-functions.html#function_json-contains" target="_blank" rel="noopener"><code>JSON_CONTAINS()</code></a></td><td>是否包含特定对象的JSON文档路径</td></tr><tr><td scope="row"><a href="https://dev.mysql.com/doc/refman/5.7/en/json-search-functions.html#function_json-contains-path" target="_blank" rel="noopener"><code>JSON_CONTAINS_PATH()</code></a></td><td>无论是JSON文件包含任何数据路径</td></tr><tr><td scope="row"><a href="https://dev.mysql.com/doc/refman/5.7/en/json-attribute-functions.html#function_json-depth" target="_blank" rel="noopener"><code>JSON_DEPTH()</code></a></td><td>JSON文档的最大深度</td></tr><tr><td scope="row"><a href="https://dev.mysql.com/doc/refman/5.7/en/json-search-functions.html#function_json-extract" target="_blank" rel="noopener"><code>JSON_EXTRACT()</code></a></td><td>从JSON文档返回数据</td></tr><tr><td scope="row"><a href="https://dev.mysql.com/doc/refman/5.7/en/json-search-functions.html#operator_json-inline-path" target="_blank" rel="noopener"><code>-&gt;&gt;</code></a></td><td>在评估路径和结束引语结果返回JSON列值；相当于json_unquote（json_extract()）。</td></tr><tr><td scope="row"><a href="https://dev.mysql.com/doc/refman/5.7/en/json-modification-functions.html#function_json-insert" target="_blank" rel="noopener"><code>JSON_INSERT()</code></a></td><td>将数据插入到JSON文档</td></tr><tr><td scope="row"><a href="https://dev.mysql.com/doc/refman/5.7/en/json-search-functions.html#function_json-keys" target="_blank" rel="noopener"><code>JSON_KEYS()</code></a></td><td>从JSON文件密钥数组</td></tr><tr><td scope="row"><a href="https://dev.mysql.com/doc/refman/5.7/en/json-attribute-functions.html#function_json-length" target="_blank" rel="noopener"><code>JSON_LENGTH()</code></a></td><td>在JSON文档中的元素数</td></tr><tr><td scope="row"><a href="https://dev.mysql.com/doc/refman/5.7/en/json-modification-functions.html#function_json-merge" target="_blank" rel="noopener"><code>JSON_MERGE()</code></a>（废弃的5.7.22）</td><td>合并的JSON文件，保存重复键。不json_merge_preserve()的同义词</td></tr><tr><td scope="row"><a href="https://dev.mysql.com/doc/refman/5.7/en/json-modification-functions.html#function_json-merge-patch" target="_blank" rel="noopener"><code>JSON_MERGE_PATCH()</code></a></td><td>合并的JSON文件，免去重复键的值</td></tr><tr><td scope="row"><a href="https://dev.mysql.com/doc/refman/5.7/en/json-modification-functions.html#function_json-merge-preserve" target="_blank" rel="noopener"><code>JSON_MERGE_PRESERVE()</code></a></td><td>合并的JSON文件，保存重复键</td></tr><tr><td scope="row"><a href="https://dev.mysql.com/doc/refman/5.7/en/json-creation-functions.html#function_json-object" target="_blank" rel="noopener"><code>JSON_OBJECT()</code></a></td><td>创建JSON对象</td></tr><tr><td scope="row"><a href="https://dev.mysql.com/doc/refman/5.7/en/json-utility-functions.html#function_json-pretty" target="_blank" rel="noopener"><code>JSON_PRETTY()</code></a></td><td>版画在人类可读的格式JSON文档，每个数组元素或对象成员打印在新的行中，缩进两个空格就其母。</td></tr><tr><td scope="row"><a href="https://dev.mysql.com/doc/refman/5.7/en/json-creation-functions.html#function_json-quote" target="_blank" rel="noopener"><code>JSON_QUOTE()</code></a></td><td>引用JSON文档</td></tr><tr><td scope="row"><a href="https://dev.mysql.com/doc/refman/5.7/en/json-modification-functions.html#function_json-remove" target="_blank" rel="noopener"><code>JSON_REMOVE()</code></a></td><td>从JSON文件中删除数据</td></tr><tr><td scope="row"><a href="https://dev.mysql.com/doc/refman/5.7/en/json-modification-functions.html#function_json-replace" target="_blank" rel="noopener"><code>JSON_REPLACE()</code></a></td><td>在JSON文件的值替换</td></tr><tr><td scope="row"><a href="https://dev.mysql.com/doc/refman/5.7/en/json-search-functions.html#function_json-search" target="_blank" rel="noopener"><code>JSON_SEARCH()</code></a></td><td>在JSON文件价值路径</td></tr><tr><td scope="row"><a href="https://dev.mysql.com/doc/refman/5.7/en/json-modification-functions.html#function_json-set" target="_blank" rel="noopener"><code>JSON_SET()</code></a></td><td>将数据插入到JSON文档</td></tr><tr><td scope="row"><a href="https://dev.mysql.com/doc/refman/5.7/en/json-utility-functions.html#function_json-storage-size" target="_blank" rel="noopener"><code>JSON_STORAGE_SIZE()</code></a></td><td>用于一个JSON文件的二进制表示形式存储空间；一个JSON柱，空间时使用的文档插入到任何部分更新之前，</td></tr><tr><td scope="row"><a href="https://dev.mysql.com/doc/refman/5.7/en/json-attribute-functions.html#function_json-type" target="_blank" rel="noopener"><code>JSON_TYPE()</code></a></td><td>JSON值类型</td></tr><tr><td scope="row"><a href="https://dev.mysql.com/doc/refman/5.7/en/json-modification-functions.html#function_json-unquote" target="_blank" rel="noopener"><code>JSON_UNQUOTE()</code></a></td><td>JSON值而言</td></tr><tr><td scope="row"><a href="https://dev.mysql.com/doc/refman/5.7/en/json-attribute-functions.html#function_json-valid" target="_blank" rel="noopener"><code>JSON_VALID()</code></a></td><td>JSON值是否是有效的</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
          <category> Json </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> Json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP中的 抽象类（abstract class）和 接口（interface）</title>
      <link href="/2020/02/02/PHP%E4%B8%AD%E7%9A%84-%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88abstract-class%EF%BC%89%E5%92%8C-%E6%8E%A5%E5%8F%A3%EF%BC%88interface%EF%BC%89/"/>
      <url>/2020/02/02/PHP%E4%B8%AD%E7%9A%84-%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88abstract-class%EF%BC%89%E5%92%8C-%E6%8E%A5%E5%8F%A3%EF%BC%88interface%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>抽象类abstract class<br><br>1 ．抽象类是指在 class 前加了 abstract 关键字且存在抽象方法（在类方法 function 关键字前加了 abstract 关键字）的类。<br><br>2 ．抽象类不能被直接实例化。抽象类中只定义（或部分实现）子类需要的方法。子类可以通过继承抽象类并通过实现抽象类中的所有抽象方法，使抽象类具体化。<br><br>3 ．如果子类需要实例化，前提是它实现了抽象类中的所有抽象方法。如果子类没有全部实现抽象类中的所有抽象方法，那么该子类也是一个抽象类，必须在 class 前面加上 abstract 关键字，并且不能被实例化。<br><br></p><pre><code>abstract class A<br>{<br>    /** 抽象类中可以定义变量 */<br>    protected  = 0;<br>    private  = 1;<br>    public  = 2;<br>    /** 也可以定义非抽象方法 */<br>    public function my_print()<br>    {<br>        echo "hello,world/n";<br>    }<br>    /**<br>     * 大多数情况下，抽象类至少含有一个抽象方法。抽象方法用abstract关键字声明，其中不能有具体内容。<br>     * 可以像声明普通类方法那样声明抽象方法，但是要以分号而不是方法体结束。也就是说抽象方法在抽象类中不能被实现，也就是没有函数体“{some codes}”。<br>     */<br>    abstract protected function abstract_func1();<br>    abstract protected function abstract_func2();<br>}<br>abstract class B extends A<br>{<br>    public function abstract_func1()<br>    {<br>       echo "implement the abstract_func1 in class A/n";<br>    }<br>    /** 这么写在zend studio 8中会报错*/<br>    //abstract protected function abstract_func2();<br>}<br>class C extends B<br>{<br>    public function abstract_func2()<br>    {<br>       echo "implement the abstract_func2 in class A/n";<br>    }<br>}</code></pre><p>4 ．如果像下面这样创建了一个继承自 A 的子类 B ，但是不实现抽象方法 abstract_func() ：<br></p><pre><code>Class B extends A{};</code></pre><p>那么程序将出现以下错误：<br></p><pre><code>Fatal error: Class B contains 1 abstract method and must therefore be declared abstract or implement the remaining methods (A::abstract_func)</code></pre><p><br>5 ．如果 B 实现了抽象方法 abstract_func() ，那么 B 中 abstract_func() 方法的访问控制不能比 A 中 abstract_func() 的访问控制更严格，也就是说：<br><br>(1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果 A 中 abstract_func() 声明为 public ，那么 B 中 abstract_func() 的声明只能是 public ，不能是 protected 或 private<br><br>(2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果 A 中 abstract_func() 声明为 protected ，那么 B 中 abstract_func() 的声明可以是 public 或 protected ，但不能是 private<br><br>(3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果 A 中 abstract_func() 声明为 private ，嘿嘿，不能定义为 private 哦！（ Fatal error : Abstract function A::abstract_func() cannot be declared private ）<br><br>二、 接口interface<br><br>1 ．抽象类提供了具体实现的标准，而接口则是纯粹的模版。接口只定义功能，而不包含实现的内容。接口用关键字 interface 来声明。<br><br>2 ． interface 是完全抽象的，只能声明方法，而且只能声明 public 的方法，不能声明 private 及 protected 的方法，不能定义方法体，也不能声明实例变量 。然而， interface 却可以声明常量变量 。但将常量变量放在 interface 中违背了其作为接口的作用而存在的宗旨，也混淆了 interface 与类的不同价值。如果的确需要，可以将其放在相应的 abstract class 或 Class 中。<br></p><pre><code>interface iA<br>{<br>    const AVAR=3;<br>    public function iAfunc1();<br>    public function iAfunc2();<br>}<br>echo iA:: AVAR;</code></pre><p>3 ．任何实现接口的类都要实现接口中所定义的所有方法</p><pre><code>class E implements iA<br>{<br>    public function iAfunc1(){echo "in iAfunc1";}<br>    public function iAfunc2(){echo "in iAfunc2";}<br>}</code></pre><p>否则该类必须声明为 abstract 。<br></p><pre><code>abstract class E implements iA{}</code></pre><p>4 ．一个类可以在声明中使用 implements 关键字来实现某个接口。这么做之后，实现接口的具体过程和继承一个仅包含抽象方法的抽象类是一样的。一个类可以同时继承一个父类和实现任意多个接口。 extends 子句应该在 implements 子句之前。 PHP 只支持继承自一个父类，因此 extends 关键字后只能跟一个类名。<br></p><pre><code>interface iB<br>{<br>    public function iBfunc1();<br>    public function iBfunc2();<br>}<br>class D extends A implements iA,iB<br>{<br>    public function abstract_func1()<br>    {<br>       echo "implement the abstract_func1 in class A/n";<br>    }<br>    public function abstract_func2()<br>    {<br>       echo "implement the abstract_func2 in class A/n";<br>    }<br>    public function iAfunc1(){echo "in iAfunc1";}<br>    public function iAfunc2(){echo "in iAfunc2";}<br>    public function iBfunc1(){echo "in iBfunc1";}<br>    public function iBfunc2(){echo "in iBfunc2";}<br>}<br> <br>class D extends B implements iA,iB<br>{<br>    public function abstract_func1()<br>    {<br>       parent::abstract_func1();<br>       echo "override the abstract_func1 in class A/n";<br>    }<br>    public function abstract_func2()<br>    {<br>       echo "implement the abstract_func2 in class A/n";<br>    }<br>    public function iAfunc1(){echo "in iAfunc1";}<br>    public function iAfunc2(){echo "in iAfunc2";}<br>    public function iBfunc1(){echo "in iBfunc1";}<br>    public function iBfunc2(){echo "in iBfunc2";}<br>}</code></pre><p>5 ．接口不可以实现另一个接口，但可以继承多个<br></p><pre><code>interface iC extends iA,iB{}<br>class F implements iC<br>{<br>    public function iAfunc1(){echo "in iAfunc1";}<br>    public function iAfunc2(){echo "in iAfunc2";}<br>    public function iBfunc1(){echo "in iBfunc1";}<br>    public function iBfunc2(){echo "in iBfunc2";}<br>}</code></pre><p>三、 抽象类和接口的异同<br><br>1. 相同点：<br><br>(1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 两者都是抽象类，都不能实例化。<br><br>(2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interface 实现类及 abstract class 的子类都必须要实现已经声明的抽象方法。<br><br>2. 不同点：<br><br>(1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interface 需要实现，要用 implements ，而 abstract class 需要继承，要用 extends 。<br><br>(2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一个类可以实现多个 interface ，但一个类只能继承一个 abstract class 。<br><br>(3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interface 强调特定功能的实现，而 abstract class 强调所属关系。<br><br>(4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 尽管 interface 实现类及 abstract class 的子类都必须要实现相应的抽象方法，但实现的形式不同。 interface 中的每一个方法都是抽象方法，都只是声明的 (declaration, 没有方法体 ) ，实现类必须要实现。而 abstract class 的子类可以有选择地实现。这个选择有两点含义： a) abstract class 中并非所有的方法都是抽象的，只有那些冠有 abstract 的方法才是抽象的，子类必须实现。那些没有 abstract 的方法，在 abstract class 中必须定义方法体； b) abstract class 的子类在继承它时，对非抽象方法既可以直接继承，也可以覆盖；而对抽象方法，可以选择实现，也可以留给其子类来实现，但此类必须也声明为抽象类。既是抽象类，当然也不能实例化。<br><br>(5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abstract class 是 interface 与 class 的中介。 abstract class 在 interface 及 class 中起到了承上启下的作用。一方面， abstract class 是抽象的，可以声明抽象方法，以规范子类必须实现的功能；另一方面，它又可以定义缺省的方法体，供子类直接使用或覆盖。另外，它还可以定义自己的实例变量，以供子类通过继承来使用。<br><br>(6)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 接口中的抽象方法前不用也不能加 abstract 关键字，默认隐式就是抽象方法，也不能加 final 关键字来防止抽象方法的继承。而抽象类中抽象方法前则必须加上 abstract 表示显示声明为抽象方法。<br><br>(7)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 接口中的抽象方法默认是 public 的，也只能是 public 的，不能用 private ， protected 修饰符修饰。而抽象类中的抽象方法则可以用 public ， protected 来修饰，但不能用 private 。<br><br>3. interface 的应用场合<br><br>(1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 类与类之间需要特定的接口进行协调，而不在乎其如何实现。<br><br>(2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 作为能够实现特定功能的标识存在，也可以是什么接口方法都没有的纯粹标识。<br><br>(3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 需要将一组类视为单一的类，而调用者只通过接口来与这组类发生联系。<br><br>(4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 需要实现特定的多项功能，而这些功能之间可能完全没有任何联系。<br><br>4. abstract class 的应用场合<br><br>一句话，在既需要统一的接口，又需要实例变量或缺省的方法的情况下，就可以使用它。最常见的有：<br><br>(1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 定义了一组接口，但又不想强迫每个实现类都必须实现所有的接口。可以用 abstract class 定义一组方法体，甚至可以是空方法体，然后由子类选择自己所感兴趣的方法来覆盖。<br><br>(2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 某些场合下，只靠纯粹的接口不能满足类与类之间的协调，还必需类中表示状态的变量来区别不同的关系。 abstract 的中介作用可以很好地满足这一点。<br><br>(3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 规范了一组相互协调的方法，其中一些方法是共同的，与状态无关的，可以共享的，无需子类分别实现；而另一些方法却需要各个子类根据自己特定的状态来实现特 定的功能 。<br>--------------------- <br>版权声明：本文为CSDN博主「sunlylorn」的原创文章，遵循CC 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。<br>原文链接：https://blog.csdn.net/sunlylorn/article/details/6124319</p>]]></content>
      
      
      <categories>
          
          <category> Php </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Php </tag>
            
            <tag> 抽象类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL 解锁与锁表</title>
      <link href="/2020/02/02/MYSQL%20%E8%A7%A3%E9%94%81%E4%B8%8E%E9%94%81%E8%A1%A8/"/>
      <url>/2020/02/02/MYSQL%20%E8%A7%A3%E9%94%81%E4%B8%8E%E9%94%81%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<div>MySQL锁概述</div><div>相对其他数据库而言，MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。比如，MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）；BDB存储引擎采用的是页面锁（page-level locking），但也支持表级锁；InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。</div><div>MySQL这3种锁的特性可大致归纳如下。</div><div><strong>开销、加锁速度、死锁、粒度、并发性能</strong></div><ul><li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</li><li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</li><li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li></ul><p><span id="more-274"></span></p><div><div>MyISAM表锁</div><div>MyISAM存储引擎只支持表锁，这也是MySQL开始几个版本中唯一支持的锁类型。随着应用对事务完整性和并发性要求的不断提高，MySQL才开始开发基于事务的存储引擎，后来慢慢出现了支持页锁的BDB存储引擎和支持行锁的InnoDB存储引擎（实际 InnoDB是单独的一个公司，现在已经被Oracle公司收购）。但是MyISAM的表锁依然是使用最为广泛的锁类型。本节将详细介绍MyISAM表锁的使用。</div><h3><a name="t0"></a><a target="_blank" name="t0"></a>查询表级锁争用情况</h3><div align="left">可以通过检查table_locks_waited和table_locks_immediate状态变量来分析系统上的表锁定争夺：</div><div><pre><code>mysql&gt;&nbsp;show status like 'table%';+-----------------------+-------+| Variable_name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Value |+-----------------------+-------+| Table_locks_immediate | 2979&nbsp; || Table_locks_waited&nbsp;&nbsp;&nbsp; | 0&nbsp;&nbsp;&nbsp;&nbsp; |+-----------------------+-------+</code></pre></div><div>2 rows in set (0.00 sec))</div><div>如果Table_locks_waited的值比较高，则说明存在着较严重的表级锁争用情况。</div><div></div><div><h3>获取InnoDB行锁争用情况</h3><div align="left">可以通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况：</div><div><pre><code>mysql&gt;&nbsp;show status like 'innodb_row_lock%';+-------------------------------+-------+| Variable_name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Value |+-------------------------------+-------+| InnoDB_row_lock_current_waits | 0&nbsp;&nbsp;&nbsp;&nbsp; || InnoDB_row_lock_time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 0&nbsp;&nbsp;&nbsp;&nbsp; || InnoDB_row_lock_time_avg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 0&nbsp;&nbsp;&nbsp;&nbsp; || InnoDB_row_lock_time_max&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 0&nbsp;&nbsp;&nbsp;&nbsp; || InnoDB_row_lock_waits&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 0&nbsp;&nbsp;&nbsp;&nbsp; |+-------------------------------+-------+5 rows in set (0.01 sec)</code></pre></div><div align="left"><strong>如果发现锁争用比较严重，如InnoDB_row_lock_waits和InnoDB_row_lock_time_avg的值比较高</strong>，还可以通过</div></div></div><p>&nbsp;</p><p><strong>解锁</strong></p><p>第一种</p><pre><code>show processlist;</code></pre><p>找到锁进程，kill id ;</p><p>&nbsp;</p><p>第二种</p><pre><code>mysql&gt;UNLOCK TABLES;</code></pre><p><strong>锁表</strong></p><p>锁定数据表，避免在备份过程中，表被更新</p><pre><code>mysql&gt;LOCK TABLES tbl_name READ;</code></pre><p>为表增加一个写锁定：</p><pre><code>mysql&gt;LOCK TABLES tbl_name WRITE;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSON与JS数组互相转换</title>
      <link href="/2020/02/02/JSON%E4%B8%8EJS%E6%95%B0%E7%BB%84%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/"/>
      <url>/2020/02/02/JSON%E4%B8%8EJS%E6%95%B0%E7%BB%84%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>Please Write Article</p><p><strong>1. JS数组转换JSON</strong></p><pre><code>var json = JSON.stringify(js_array)</code></pre><p><strong>2. JSON转换JS数组</strong></p><pre><code>var js_array = JSON.parse(json)</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO 设置 GOROOT 和 GOPATH</title>
      <link href="/2020/02/02/GO%20%E8%AE%BE%E7%BD%AE%20GOROOT%20%E5%92%8C%20GOPATH/"/>
      <url>/2020/02/02/GO%20%E8%AE%BE%E7%BD%AE%20GOROOT%20%E5%92%8C%20GOPATH/</url>
      
        <content type="html"><![CDATA[<p>go 里面有两个非常重要的环境变量 GOROOT 和 GOPATH，其中 GOROOT 是安装 go 的路径，而 GOPATH 是我们定义的自己的工作空间。</p><p>如果在安装的时候是一路 next 完的，那么默认就配置好了 ，无需手动配置。</p><p>如果在安装的时候修改了默认的安装路径，那么可能需要自己添加一下 。</p><p><span id="more-189"></span></p><ol><li>首先在环境变量中添加 GOPATH，值为 go 的安装目录：</li><li>然后在环境变量 PATH 中添加 go 安装目录下的 bin 文件夹。</li><li>接着添加一个环境变量 GOPATH，值为你自己希望的工作目录。</li><li>最后重启一下 命令行工具，输入 go env 命令即可查看：</li></ol><p>Tips:</p><p>一定要记得重启下命令行工具，cmd 或者 cmder 啥的，不然修改的环境变量没有生效，我一开始忘记了重启，纳闷半天为啥没生效。</p><p>原文：https://blog.csdn.net/xs20691718/article/details/78089163</p>]]></content>
      
      
      <categories>
          
          <category> GoLang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RESTful 架构详解</title>
      <link href="/2020/02/02/RESTful%20%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/02/02/RESTful%20%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2>1. 什么是REST</h2><p></p><p>REST全称是Representational State Transfer，中文意思是表述（编者注：通常译为表征）性状态转移。 它首次出现在2000年Roy Fielding的博士论文中，Roy Fielding是HTTP规范的主要编写者之一。 他在论文中提到：”我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。REST指的是一组架构约束条件和原则。” 如果一个架构符合REST的约束条件和原则，我们就称它为RESTful架构。</p><p><span id="more-171"></span></p><p>REST本身并没有创造新的技术、组件或服务，而隐藏在RESTful背后的理念就是使用Web的现有特征和能力， 更好地使用现有Web标准中的一些准则和约束。虽然REST本身受Web技术的影响很深， 但是理论上REST架构风格并不是绑定在HTTP上，只不过目前HTTP是唯一与REST相关的实例。 所以我们这里描述的REST也是通过HTTP实现的REST。</p><h2>2. 理解RESTful</h2><p>要理解RESTful架构，需要理解Representational State Transfer这个词组到底是什么意思，它的每一个词都有些什么涵义。</p><p>下面我们结合REST原则，围绕资源展开讨论，从资源的定义、获取、表述、关联、状态变迁等角度，列举一些关键概念并加以解释。</p><ul><li>资源与URI</li><li>统一资源接口</li><li>资源的表述</li><li>资源的链接</li><li>状态的转移</li></ul><h2>2. 1 资源与URI</h2><p>REST全称是表述性状态转移，那究竟指的是什么的表述? 其实指的就是资源。任何事物，只要有被引用到的必要，它就是一个资源。资源可以是实体(例如手机号码)，也可以只是一个抽象概念(例如价值) 。下面是一些资源的例子：</p><ul><li>某用户的手机号码</li><li>某用户的个人信息</li><li>最多用户订购的GPRS套餐</li><li>两个产品之间的依赖关系</li><li>某用户可以办理的优惠套餐</li><li>某手机号码的潜在价值</li></ul><p>要让一个资源可以被识别，需要有个唯一标识，在Web中这个唯一标识就是URI(Uniform Resource Identifier)。</p><p>URI既可以看成是资源的地址，也可以看成是资源的名称。如果某些信息没有使用URI来表示，那它就不能算是一个资源， 只能算是资源的一些信息而已。URI的设计应该遵循可寻址性原则，具有自描述性，需要在形式上给人以直觉上的关联。这里以github网站为例，给出一些还算不错的URI：</p><ul><li>https://github.com/git</li><li>https://github.com/git/git</li><li>https://github.com/git/git/blob/master/block-sha1/sha1.h</li><li>https://github.com/git/git/commit/e3af72cdafab5993d18fae056f87e1d675913d08</li><li>https://github.com/git/git/pulls</li><li>https://github.com/git/git/pulls?state=closed</li><li>https://github.com/git/git/compare/master…next</li></ul><p>下面让我们来看看URI设计上的一些技巧:</p><ul><li>使用_或-来让URI可读性更好</li></ul><p>曾经Web上的URI都是冰冷的数字或者无意义的字符串，但现在越来越多的网站使用_或-来分隔一些单词，让URI看上去更为人性化。 例如国内比较出名的开源中国社区，它上面的新闻地址就采用这种风格， 如http://www.oschina.net/news/38119/oschina-translate-reward-plan。</p><ul><li>使用/来表示资源的层级关系</li></ul><p>例如上述/git/git/commit/e3af72cdafab5993d18fae056f87e1d675913d08就表示了一个多级的资源， 指的是git用户的git项目的某次提交记录，又例如/orders/2012/10可以用来表示2012年10月的订单记录。</p><ul><li>使用?用来过滤资源</li></ul><p>很多人只是把?简单的当做是参数的传递，很容易造成URI过于复杂、难以理解。可以把?用于对资源的过滤， 例如/git/git/pulls用来表示git项目的所有推入请求，而/pulls?state=closed用来表示git项目中已经关闭的推入请求， 这种URL通常对应的是一些特定条件的查询结果或算法运算结果。</p><ul><li>,或;可以用来表示同级资源的关系</li></ul><p>有时候我们需要表示同级资源的关系时，可以使用,或;来进行分割。例如哪天github可以比较某个文件在随意两次提交记录之间的差异，或许可以使用/git/git /block-sha1/sha1.h/compare/e3af72cdafab5993d18fae056f87e1d675913d08;bd63e61bdf38e872d5215c07b264dcc16e4febca作为URI。 不过，现在github是使用…来做这个事情的，例如/git/git/compare/master…next。</p><h2>2. 2 统一资源接口</h2><p>RESTful架构应该遵循统一接口原则，统一接口包含了一组受限的预定义的操作，不论什么样的资源，都是通过使用相同的接口进行资源的访问。接口应该使用标准的HTTP方法如GET，PUT和POST，并遵循这些方法的语义。</p><p>如果按照HTTP方法的语义来暴露资源，那么接口将会拥有安全性和幂等性的特性，例如GET和HEAD请求都是安全的， 无论请求多少次，都不会改变服务器状态。而GET、HEAD、PUT和DELETE请求都是幂等的，无论对资源操作多少次， 结果总是一样的，后面的请求并不会产生比第一次更多的影响。</p><p>下面列出了GET，DELETE，PUT和POST的典型用法:</p><h2>GET</h2><ul><li>安全且幂等</li><li>获取表示</li><li>变更时获取表示（缓存）</li></ul><ul><li>200（OK） – 表示已在响应中发出</li></ul><ul><li>204（无内容） – 资源有空表示</li><li>301（Moved Permanently） – 资源的URI已被更新</li><li>303（See Other） – 其他（如，负载均衡）</li><li>304（not modified）- 资源未更改（缓存）</li><li>400 （bad request）- 指代坏请求（如，参数错误）</li><li>404 （not found）- 资源不存在</li><li>406 （not acceptable）- 服务端不支持所需表示</li><li>500 （internal server error）- 通用错误响应</li><li>503 （Service Unavailable）- 服务端当前无法处理请求</li></ul><h2>POST</h2><ul><li>不安全且不幂等</li><li>使用服务端管理的（自动产生）的实例号创建资源</li><li>创建子资源</li><li>部分更新资源</li><li>如果没有被修改，则不过更新资源（乐观锁）</li></ul><ul><li>200（OK）- 如果现有资源已被更改</li></ul><ul><li>201（created）- 如果新资源被创建</li><li>202（accepted）- 已接受处理请求但尚未完成（异步处理）</li><li>301（Moved Permanently）- 资源的URI被更新</li><li>303（See Other）- 其他（如，负载均衡）</li><li>400（bad request）- 指代坏请求</li><li>404 （not found）- 资源不存在</li><li>406 （not acceptable）- 服务端不支持所需表示</li><li>409 （conflict）- 通用冲突</li><li>412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突）</li><li>415 （unsupported media type）- 接受到的表示不受支持</li><li>500 （internal server error）- 通用错误响应</li><li>503 （Service Unavailable）- 服务当前无法处理请求</li></ul><h2>PUT</h2><ul><li>不安全但幂等</li><li>用客户端管理的实例号创建一个资源</li><li>通过替换的方式更新资源</li><li>如果未被修改，则更新资源（乐观锁）</li></ul><ul><li>200 （OK）- 如果已存在资源被更改</li></ul><ul><li>201 （created）- 如果新资源被创建</li><li>301（Moved Permanently）- 资源的URI已更改</li><li>303 （See Other）- 其他（如，负载均衡）</li><li>400 （bad request）- 指代坏请求</li><li>404 （not found）- 资源不存在</li><li>406 （not acceptable）- 服务端不支持所需表示</li><li>409 （conflict）- 通用冲突</li><li>412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突）</li><li>415 （unsupported media type）- 接受到的表示不受支持</li><li>500 （internal server error）- 通用错误响应</li><li>503 （Service Unavailable）- 服务当前无法处理请求</li></ul><h2>DELETE</h2><ul><li>不安全但幂等</li><li>删除资源</li></ul><ul><li>200 （OK）- 资源已被删除</li></ul><ul><li>301 （Moved Permanently）- 资源的URI已更改</li><li>303 （See Other）- 其他，如负载均衡</li><li>400 （bad request）- 指代坏请求</li><li>404 （not found）- 资源不存在</li><li>409 （conflict）- 通用冲突</li><li>500 （internal server error）- 通用错误响应</li><li>503 （Service Unavailable）- 服务端当前无法处理请求</li></ul><p>下面我们来看一些实践中常见的问题:</p><ul><li>POST和PUT用于创建资源时有什么区别?</li></ul><p>POST和PUT在创建资源的区别在于，所创建的资源的名称(URI)是否由客户端决定。 例如为我的博文增加一个java的分类，生成的路径就是分类名/categories/java，那么就可以采用PUT方法。不过很多人直接把POST、GET、PUT、DELETE直接对应上CRUD，例如在一个典型的rails实现的RESTful应用中就是这么做的。</p><p>我认为，这是因为rails默认使用服务端生成的ID作为URI的缘故，而不少人就是通过rails实践REST的，所以很容易造成这种误解。</p><ul><li>客户端不一定都支持这些HTTP方法吧?</li></ul><p>的确有这种情况，特别是一些比较古老的基于浏览器的客户端，只能支持GET和POST两种方法。</p><p>在实践上，客户端和服务端都可能需要做一些妥协。例如rails框架就支持通过隐藏参数_method=DELETE来传递真实的请求方法， 而像Backbone这样的客户端MVC框架则允许传递_method传输和设置X-HTTP-Method-Override头来规避这个问题。</p><ul><li>统一接口是否意味着不能扩展带特殊语义的方法?</li></ul><p>统一接口并不阻止你扩展方法，只要方法对资源的操作有着具体的、可识别的语义即可，并能够保持整个接口的统一性。</p><p>像WebDAV就对HTTP方法进行了扩展，增加了LOCK、UPLOCK等方法。而github的API则支持使用PATCH方法来进行issue的更新，例如:</p><pre>PATCH /repos/:owner/:repo/issues/:number</pre><p>不过，需要注意的是，像PATCH这种不是HTTP标准方法的，服务端需要考虑客户端是否能够支持的问题。</p><ul><li>统一资源接口对URI有什么指导意义?</li></ul><p>统一资源接口要求使用标准的HTTP方法对资源进行操作，所以URI只应该来表示资源的名称，而不应该包括资源的操作。</p><p>通俗来说，URI不应该使用动作来描述。例如，下面是一些不符合统一接口要求的URI:</p><ul><li>GET /getUser/1</li><li>POST /createUser</li><li>PUT /updateUser/1</li><li>DELETE /deleteUser/1</li></ul><p>如果GET请求增加计数器，这是否违反安全性?</p><p>安全性不代表请求不产生副作用，例如像很多API开发平台，都对请求流量做限制。像github，就会限制没有认证的请求每小时只能请求60次。</p><p>但客户端不是为了追求副作用而发出这些GET或HEAD请求的，产生副作用是服务端”自作主张”的。</p><p>另外，服务端在设计时，也不应该让副作用太大，因为客户端认为这些请求是不会产生副作用的。</p><ul><li>直接忽视缓存可取吗?</li></ul><p>即使你按各个动词的原本意图来使用它们，你仍可以轻易禁止缓存机制。 最简单的做法就是在你的HTTP响应里增加这样一个报头： Cache-control: no-cache。 但是，同时你也对失去了高效的缓存与再验证的支持(使用Etag等机制)。</p><p>对于客户端来说，在为一个REST式服务实现程序客户端时，也应该充分利用现有的缓存机制，以免每次都重新获取表示。</p><ul><li>响应代码的处理有必要吗?</li></ul><p>HTTP的响应代码可用于应付不同场合，正确使用这些状态代码意味着客户端与服务器可以在一个具备较丰富语义的层次上进行沟通。</p><p>例如，201（”Created”）响应代码表明已经创建了一个新的资源，其URI在Location响应报头里。</p><p>假如你不利用HTTP状态代码丰富的应用语义，那么你将错失提高重用性、增强互操作性和提升松耦合性的机会。</p><p>如果这些所谓的RESTful应用必须通过响应实体才能给出错误信息，那么SOAP就是这样的了，它就能够满足了。</p><h2>2. 3 资源的表述</h2><p>上面提到，客户端通过HTTP方法可以获取资源，是吧? 不，确切的说，客户端获取的只是资源的表述而已。 资源在外界的具体呈现，可以有多种表述(或成为表现、表示)形式，在客户端和服务端之间传送的也是资源的表述，而不是资源本身。 例如文本资源可以采用html、xml、json等格式，图片可以使用PNG或JPG展现出来。</p><p>资源的表述包括数据和描述数据的元数据，例如，HTTP头”Content-Type” 就是这样一个元数据属性。</p><p>那么客户端如何知道服务端提供哪种表述形式呢?</p><p>答案是可以通过HTTP内容协商，客户端可以通过Accept头请求一种特定格式的表述，服务端则通过Content-Type告诉客户端资源的表述形式。</p><p>以github为例，请求某组织资源的json格式的表述形式:</p><p><br></p><p></p><p>&nbsp;</p><p>假如github也能够支持xml格式的表述格式，那么结果就是这样的:</p><p><br></p><p></p><p>&nbsp;</p><p>下面我们来看一些实践上常见的设计:</p><h2>在URI里边带上版本号</h2><p>有些API在URI里边带上版本号，例如:</p><ul><li>http://api.example.com/1.0/foo</li><li>http://api.example.com/1.2/foo</li><li>http://api.example.com/2.0/foo</li></ul><p>如果我们把版本号理解成资源的不同表述形式的话，就应该只是用一个URL，并通过Accept头部来区分，还是以github为例，它的Accept的完整格式是:application/vnd.github[.version].param[+json]</p><p>对于v3版本的话，就是Accept: application/vnd.github.v3。对于上面的例子，同理可以使用使用下面的头部:</p><ul><li>Accept: vnd.example-com.foo+json; version=1.0</li><li>Accept: vnd.example-com.foo+json; version=1.2</li><li>Accept: vnd.example-com.foo+json; version=2.0</li></ul><h2>使用URI后缀来区分表述格式</h2><p>像rails框架，就支持使用/users.xml或/users.json来区分不同的格式。 这样的方式对于客户端来说，无疑是更为直观，但混淆了资源的名称和资源的表述形式。 我个人认为，还是应该优先使用内容协商来区分表述格式。</p><h2>如何处理不支持的表述格式</h2><p>当服务器不支持所请求的表述格式，那么应该怎么办？若服务器不支持，它应该返回一个HTTP 406响应，表示拒绝处理该请求。下面以github为例，展示了一个请求XML表述资源的结果：</p><p></p><p>&nbsp;</p><h2>2. 4 资源的链接</h2><p>我们知道REST是使用标准的HTTP方法来操作资源的，但仅仅因此就理解成带CURD的Web数据库架构就太过于简单了。</p><p>这种反模式忽略了一个核心概念：”超媒体即应用状态引擎（hypermedia as the engine of application state）”。 超媒体是什么?</p><p>当你浏览Web网页时，从一个连接跳到一个页面，再从另一个连接跳到另外一个页面，就是利用了超媒体的概念：把一个个把资源链接起来.</p><p>要达到这个目的，就要求在表述格式里边加入链接来引导客户端。在《RESTful Web Services》一书中，作者把这种具有链接的特性成为连通性。下面我们具体来看一些例子。</p><p>下面展示的是github获取某个组织下的项目列表的请求，可以看到在响应头里边增加Link头告诉客户端怎么访问下一页和最后一页的记录。 而在响应体里边，用url来链接项目所有者和项目地址。</p><p></p><p>　　又例如下面这个例子，创建订单后通过链接引导客户端如何去付款。</p><p></p><p>上面的例子展示了如何使用超媒体来增强资源的连通性。很多人在设计RESTful架构时，使用很多时间来寻找漂亮的URI，而忽略了超媒体。所以，应该多花一些时间来给资源的表述提供链接，而不是专注于”资源的CRUD”。</p><h2>2. 5 状态的转移</h2><p>有了上面的铺垫，再讨论REST里边的状态转移就会很容易理解了。</p><p>不过，我们先来讨论一下REST原则中的无状态通信原则。初看一下，好像自相矛盾了，既然无状态，何来状态转移一说?</p><p>其实，这里说的无状态通信原则，并不是说客户端应用不能有状态，而是指服务端不应该保存客户端状态。</p><h2>2. 5.1 应用状态与资源状态</h2><p>实际上，状态应该区分应用状态和资源状态，客户端负责维护应用状态，而服务端维护资源状态。</p><p>客户端与服务端的交互必须是无状态的，并在每一次请求中包含处理该请求所需的一切信息。</p><p>服务端不需要在请求间保留应用状态，只有在接受到实际请求的时候，服务端才会关注应用状态。</p><p>这种无状态通信原则，使得服务端和中介能够理解独立的请求和响应。</p><p>在多次请求中，同一客户端也不再需要依赖于同一服务器，方便实现高可扩展和高可用性的服务端。</p><p>但有时候我们会做出违反无状态通信原则的设计，例如利用Cookie跟踪某个服务端会话状态，常见的像J2EE里边的JSESSIONID。</p><p>这意味着，浏览器随各次请求发出去的Cookie是被用于构建会话状态的。</p><p>当然，如果Cookie保存的是一些服务器不依赖于会话状态即可验证的信息（比如认证令牌），这样的Cookie也是符合REST原则的。</p><h2>2. 5.2 应用状态的转移</h2><p>状态转移到这里已经很好理解了， “会话”状态不是作为资源状态保存在服务端的，而是被客户端作为应用状态进行跟踪的。客户端应用状态在服务端提供的超媒体的指引下发生变迁。服务端通过超媒体告诉客户端当前状态有哪些后续状态可以进入。</p><p>这些类似”下一页”之类的链接起的就是这种推进状态的作用——指引你如何从当前状态进入下一个可能的状态。</p><h2>3. 总结</h2><p>现在广东XXX版本、XXX等项目中均使用传统的RPC、SOAP方式的Web服务，而移动南方基地XXXX项目的后台， 虽然采用了JSON格式进行交互，但还是属于RPC风格的。本文从资源的定义、获取、表述、关联、状态变迁等角度， 试图快速理解RESTful架构背后的概念。RESTful架构与传统的RPC、SOAP等方式在理念上有很大的不同，希望本文能对各位理解REST有所帮助。</p><p>&nbsp;</p><p><pmargin: 0px="" 24px;="" padding:="" 0px;="" color:="" rgb(77,="" 77,="" 77);="" font-family:="" &quot;microsoft="" yahei&quot;;="" font-size:="" 16px;="" font-style:="" normal;="" font-variant-ligatures:="" font-variant-caps:="" font-weight:="" 400;="" letter-spacing:="" orphans:="" 2;="" text-align:="" start;="" text-indent:="" text-transform:="" none;="" white-space:="" widows:="" word-spacing:="" -webkit-text-stroke-width:="" text-decoration-style:="" initial;="" text-decoration-color:="" initial;"=""><pmargin: 0px="" 24px;="" padding:="" 0px;="" color:="" rgb(77,="" 77,="" 77);="" font-family:="" &quot;microsoft="" yahei&quot;;="" font-size:="" 16px;="" font-style:="" normal;="" font-variant-ligatures:="" font-variant-caps:="" font-weight:="" 400;="" letter-spacing:="" orphans:="" 2;="" text-align:="" start;="" text-indent:="" text-transform:="" none;="" white-space:="" widows:="" word-spacing:="" -webkit-text-stroke-width:="" text-decoration-style:="" initial;="" text-decoration-color:="" initial;"=""><pmargin: 0px="" 24px;="" padding:="" 0px;="" color:="" rgb(77,="" 77,="" 77);="" font-family:="" &quot;microsoft="" yahei&quot;;="" font-size:="" 16px;="" font-style:="" normal;="" font-variant-ligatures:="" font-variant-caps:="" font-weight:="" 400;="" letter-spacing:="" orphans:="" 2;="" text-align:="" start;="" text-indent:="" text-transform:="" none;="" white-space:="" widows:="" word-spacing:="" -webkit-text-stroke-width:="" text-decoration-style:="" initial;="" text-decoration-color:="" initial;"=""><pmargin: 0px="" 24px;="" padding:="" 0px;="" color:="" rgb(77,="" 77,="" 77);="" font-family:="" &quot;microsoft="" yahei&quot;;="" font-size:="" 16px;="" font-style:="" normal;="" font-variant-ligatures:="" font-variant-caps:="" font-weight:="" 400;="" letter-spacing:="" orphans:="" 2;="" text-align:="" start;="" text-indent:="" text-transform:="" none;="" white-space:="" widows:="" word-spacing:="" -webkit-text-stroke-width:="" text-decoration-style:="" initial;="" text-decoration-color:="" initial;"=""><pmargin: 0px="" 24px;="" padding:="" 0px;="" color:="" rgb(77,="" 77,="" 77);="" font-family:="" &quot;microsoft="" yahei&quot;;="" font-size:="" 16px;="" font-style:="" normal;="" font-variant-ligatures:="" font-variant-caps:="" font-weight:="" 400;="" letter-spacing:="" orphans:="" 2;="" text-align:="" start;="" text-indent:="" text-transform:="" none;="" white-space:="" widows:="" word-spacing:="" -webkit-text-stroke-width:="" text-decoration-style:="" initial;="" text-decoration-color:="" initial;"=""></pmargin:></pmargin:></pmargin:></pmargin:></pmargin:></p><p>原文链接：https://www.runoob.com/w3cnote/restful-architecture.html</p><p><br></p>]]></content>
      
      
      <categories>
          
          <category> RESTful </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RESTful </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Principles of good RESTful API Design</title>
      <link href="/2020/02/02/Principles%20of%20good%20RESTful%20API%20Design/"/>
      <url>/2020/02/02/Principles%20of%20good%20RESTful%20API%20Design/</url>
      
        <content type="html"><![CDATA[<p>Please Write Article</p><p>Good restful API design is hard! An API represents a contract between you and those who Consume your data. Breaking this contract will result in many angry emails, and a slew of sad users with mobile apps which no longer work. Documentation is half the battle, and it is very difficult to find programmer who also likes to write.</p><p>Building an API is one of the most important things you can do to increase the value of your service. By having an API, your service / core application has the potential to become a platform from which other services grow. Look at the current huge tech companies: Facebook, Twitter, Google, GitHub, Amazon, Netflix… None of them would be nearly as big as they are today if they hadn’t opened up their data via API. In fact, an entire industry exists with the sole purpose of consuming data provided by said platforms.</p><blockquote><p>The easier your API is to consume, the more people that will consume it.</p></blockquote><p>The principles of this document, if followed closely when designing your API, will ensure that Consumers of your API will be able to understand what is going on, and should drastically reduce the number of confused and/or angry emails you receive. I’ve organized everything into topics, which don’t necessarily need to be read in order.</p><p><span id="more-174"></span></p><h3 id="restful-api-design-definitions">RESTful API Design Definitions</h3><p>Here’s a few of the important terms I will use throughout the course of this document:</p><ul><li><strong>Resource</strong>: A single instance of an object. For example, an animal.</li><li><strong>Collection</strong>: A collection of homogeneous objects. For example, animals.</li><li><strong>HTTP</strong>: A protocol for communicating over a network.</li><li><strong>Consumer</strong>: A client computer application capable of making HTTP requests.</li><li><strong>Third Party Developer</strong>: A developer not a part of your project but who wishes to consume your data.</li><li><strong>Server</strong>: An HTTP server/application accessible from a Consumer over a network.</li><li><strong>Endpoint</strong>: An API URL on a Server which represents either a Resource or an entire Collection.</li><li><strong>Idempotent</strong>: Side-effect free, can happen multiple times without penalty.</li><li><strong>URL Segment</strong>: A slash-separated piece of information in the URL.</li></ul><h3 id=">Data Design and Abstraction</h3><p>Planning how your API will look begins earlier than you’d think; first you need to decide how your data will be designed and how your core service / application will work. If you’re doing&nbsp;<a href=" http:="" blog.pop.co="" post="" 67465239611="" why-we-chose-api-first-development"="">API First Development&nbsp;this should be easy. If you’re attaching an API to an existing project, you may need to provide more abstraction.<p></p><p>Occasionally, a Collection can represent a database table, and a Resource can represent a row within that table. However, this is not the usual case. In fact, your API should abstract away as much of your data and business logic as possible. It is very important that you don’t overwhelm Third-Party Developers with any complex application data, if you do they won’t want to use your API.</p><p>There are also many parts of your service which you SHOULD NOT expose via API at all. A common example is that many APIs will not allow third parties to create users.</p></h3><h3 id="verbs">Verbs</h3><p>Surely you know about GET and POST requests. These are the two most commonly requests used when your browser visits different webpages. The term POST is so popular that it has even invaded common language, where people who know nothing about how the Internet works do know they can “post” something on a friends Facebook wall.</p><p>There are four and a half very important HTTP verbs that you need to know about. I say “and a half”, because the PATCH verb is very similar to the PUT verb, and two two are often combined by many an API developer. Here are the verbs, and next to them are their associated database call (I’m assuming most people reading this know more about writing to a database than designing an API).</p><ul><li><strong>GET</strong>&nbsp;(SELECT): Retrieve a specific Resource from the Server, or a listing of Resources.</li><li><strong>POST</strong>&nbsp;(CREATE): Create a new Resource on the Server.</li><li><strong>PUT</strong>&nbsp;(UPDATE): Update a Resource on the Server, providing the entire Resource.</li><li><strong>PATCH</strong>&nbsp;(UPDATE): Update a Resource on the Server, providing only changed attributes.</li><li><strong>DELETE</strong>&nbsp;(DELETE): Remove a Resource from the Server.</li></ul><p>Here are two lesser known HTTP verbs:</p><ul><li><strong>HEAD</strong>&nbsp;– Retrieve meta data about a Resource, such as a hash of the data or when it was last updated.</li><li><strong>OPTIONS</strong>&nbsp;– Retrieve information about what the Consumer is allowed to do with the Resource.</li></ul><p>A good RESTful API will make use of the four and a half HTTP verbs for allowing third parties to interact with its data, and will never include actions / verbs as URL segments.</p><p>Typically, GET requests can be cached (and often are!) Browsers, for example, will cache GET requests (depending on cache headers), and will go as far as prompt the user if they attempt to POST for a second time. A HEAD request is basically a GET without the response body, and can be cached as well.</p><h3 id="versioning">Versioning</h3><p>No matter what you are building, no matter how much planning you do beforehand, your core application is going to change, your data relationships will change, attributes will invariably be added and removed from your Resources. This is just how software development works, and is especially true if your project is alive and used by many people (which is likely the case if you’re building an API).</p><p>Remember than an API is a published contract between a Server and a Consumer. If you make changes to the Servers API and these changes break backwards compatibility, you will break things for your Consumer and they will resent you for it. Do it enough, and they will leave. To ensure your application evolves AND you keep your Consumers happy, you need to occasionally introduce new versions of the API while still allowing old versions to be accessible.</p><p>As a side note, if you are simply ADDING new features to your API, such as new attributes on a Resource (which are not required and the Resource will function without), or if you are ADDING new Endpoints, you do not need to increment your API version number since these changes do not break backwards compatibility. You will want to update your API Documentation (your Contract), of course.</p><p>Over time you can deprecate old versions of the API. To deprecate a feature doesn’t mean to shut if off or diminish the quality of it, but to tell Consumers of your API that the older version will be removed on a specific date and that they should upgrade to a newer version.</p><p>A good RESTful API design will keep track of the version in the URL. The other most common solution is to put a version number in a request header, but after working with many different Third Party Developers, I can tell you that adding headers is no where near as easy as adding a URL Segment.</p><h3 id="span-style-font-size-1-17em-line-height-1-5em-analytics-span">Analytics</h3><p>Keep track of the version/endpoints of your API being used by Consumers. This can be as simple as incrementing an integer in a database each time a request is made. There are many reasons that keeping track of API Analytics is a good idea, for example, the most commonly used API calls should be made efficient.</p><p>For the purposes of building an API which Third Party Developers will love, the most important thing is that when you do deprecate a version of your API, you can actually contact developers using deprecated API features. This is the perfect way to remind them to upgrade before you kill the old API version.</p><p>The process of Third Party Developer notification can be automated, e.g. mail the developer every time 10,000 requests to a deprecated feature are made.</p><h3 id="api-root-url">API Root URL</h3><p>The root location of your API is important, believe it or not. When a developer (read as code archaeologist) inherits an old project using your API and needs to build new features, they may not know about your service at all. Perhaps all they know is a list of URLs which the Consumer calls out to. It’s important that the root entry point into your API is as simple as possible, as a long complex URL will appear daunting and can turn developers away.</p><p>Here are two common URL Roots:</p><ul><li><a href="https://example.org/api/v1/*" target="_blank" rel="noopener">https://example.org/api/v1/*</a></li><li><a href="https://api.example.com/v1/*" target="_blank" rel="noopener">https://api.example.com/v1/*</a></li></ul><p>If your application is huge, or you anticipate it becoming huge, putting the API on its own subdomain (e.g.&nbsp;<strong>api.</strong>) is a good choice. This can allow for some more flexible scalability down the road.</p><p>If you anticipate your API will never grow to be that large, or you want a much simpler application setup (e.g. you want to host the website AND API from the same framework), placing your API beneath a URL segment at the root of the domain (e.g.&nbsp;<strong>/api/</strong>) works as well.</p><p>It’s a good idea to have content at the root of your API. Hitting the root of GitHub’s API returns a listing of endpoints, for example. Personally, I’m a fan of having the root URL give information which a lost developer would find useful, e.g., how to get to the developer documentation for the API.</p><p>Also, notice the HTTPS prefix. As a good RESTful API, you must host your API behind HTTPS.</p><h3 id="endpoints">Endpoints</h3><p>An Endpoint is a URL within your API which points to a specific Resource or a Collection of Resources.</p><p>If you were building a fictional API to represent several different Zoo’s, each containing many Animals (with an animal belonging to exactly one Zoo), employees (who can work at multiple zoos) and keeping track of the species of each animal, you might have the following endpoints:</p><ul><li><a href="https://api.example.com/v1/**zoos**" target="_blank" rel="noopener">https://api.example.com/v1/**zoos**</a></li><li><a href="https://api.example.com/v1/**animals**" target="_blank" rel="noopener">https://api.example.com/v1/**animals**</a></li><li><a href="https://api.example.com/v1/**animal_types**" target="_blank" rel="noopener">https://api.example.com/v1/**animal_types**</a></li><li><a href="https://api.example.com/v1/**employees**" target="_blank" rel="noopener">https://api.example.com/v1/**employees**</a></li></ul><p>When referring to what each endpoint can do, you’ll want to list valid HTTP Verb and Endpoint combinations. For example, here’s a semi-comprehensive list of actions one can perform with our fictional API. Notice that I’ve preceded each endpoint with the HTTP Verb, as this is the same notation used within an HTTP Request header.</p><ul><li>GET /zoos: List all Zoos (ID and Name, not too much detail)</li><li>POST /zoos: Create a new Zoo</li><li>GET /zoos/ZID: Retrieve an entire Zoo object</li><li>PUT /zoos/ZID: Update a Zoo (entire object)</li><li>PATCH /zoos/ZID: Update a Zoo (partial object)</li><li>DELETE /zoos/ZID: Delete a Zoo</li><li>GET /zoos/ZID/animals: Retrieve a listing of Animals (ID and Name).</li><li>GET /animals: List all Animals (ID and Name).</li><li>POST /animals: Create a new Animal</li><li>GET /animals/AID: Retrieve an Animal object</li><li>PUT /animals/AID: Update an Animal (entire object)</li><li>PATCH /animals/AID: Update an Animal (partial object)</li><li>GET /animal_types: Retrieve a listing (ID and Name) of all Animal Types</li><li>GET /animal_types/ATID: Retrieve an entire Animal Type object</li><li>GET /employees: Retrieve an entire list of Employees</li><li>GET /employees/EID: Retreive a specific Employee</li><li>GET /zoos/ZID/employees: Retrieve a listing of Employees (ID and Name) who work at this Zoo</li><li>POST /employees: Create a new Employee</li><li>POST /zoos/ZID/employees: Hire an Employee at a specific Zoo</li><li>DELETE /zoos/ZID/employees/EID: Fire an Employee from a specific Zoo</li></ul><p>In the above list, ZID means Zoo ID, AID means Animal ID, EID means Employee ID, and ATID means Animal Type ID. Having a key in your documentation for whatever convention you choose is a good idea.</p><p>I’ve left out the common API URL prefix in the above examples for brevity. While this can be fine during communications, in your actual API documentation, you should always display the full URL to each endpoint (e.g. GET&nbsp;<a href="http://api.example.com/v1/animal_type/ATID" target="_blank" rel="noopener">http://api.example.com/v1/animal_type/ATID</a>).</p><p>Notice how the relationships between data is displayed, specifically the many to many relationships between employees and zoos. By adding an additional URL segment, one can perform more specific interactions. Of course there is no HTTP verb for “FIRE”-ing an employee, but by performing a DELETE on an Employee located within a Zoo, we’re able to achieve the same effect.</p><h3 id="filtering">Filtering</h3><p>When a Consumer makes a request for a listing of objects, it is important that you give them a list of every single object matching the requested criteria. This list could be massive. But, it is important that you don’t perform any arbitrary limitations of the data. It is these arbitrary limits which make it hard for a third party developer to know what is going on.&nbsp;If they request a certain Collection, and iterate over the results, and they never see more than 100 items, it is now their job to figure out where this limit is coming from. Is their ORM buggy and limiting items to 100? Is the network chopping up large packets?</p><blockquote><p>Minimize the arbitrary limits imposed on Third Party Developers.</p></blockquote><p>It is important, however, that you do offer the ability for a Consumer to specify some sort of filtering/limitation of the results. The most important reason for this is that the network activity is minimal and the Consumer gets their results back as soon as possible. The second most important reason for this is the Consumer may be lazy, and if the Server can do filtering and pagination for them, all the better. The not-so-important reason (from the Consumers perspective), yet a great benefit for the Server, is that the request will be less resource heavy.</p><p>Filtering is mostly useful for performing GETs on Collections of resources. Since these are GET requests, filtering information should be passed via the URL. Here are some examples of the types of filtering you could conceivably add to your API:</p><ul><li>?limit=10: Reduce the number of results returned to the Consumer (for Pagination)</li><li>?offset=10: Send sets of information to the Consumer (for Pagination)</li><li>?animal_type_id=1: Filter records which match the following condition (WHERE animal_type_id = 1)</li><li>?sortby=name&amp;order=asc: Sort the results based on the specified attribute (ORDER BY `name` ASC)</li></ul><p>Some of these filterings can be redundant with endpoint URLS. For example I previously mentioned GET /zoo/ZID/animals. This would be the same thing as GET /animals?zoo_id=ZID. Dedicated endpoints being made available to the Consumer will make their lives easier, this is especially true with requests you anticipate they will make a lot. In the documentation, mention this redundancy so that Third Party Developers aren’t left wondering if differences exist.</p><p>Also, this goes without saying, but whenever you perform filtering or sorting of data, make sure you white-list the columns for which the Consumer can filter and sort by. We don’t want any database errors being sent to Consumers!</p><h3 id="status-codes">Status Codes</h3><p>It is very important that as a RESTful API, you make use of the proper HTTP Status Codes; they are a standard after all! Various network equipment is able to read these status codes, e.g. load balancers can be configured to avoid sending requests to a web server sending out lots of 50x errors. There are a&nbsp;<a title="HTTP Status Codes" href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html" target="_blank" rel="noopener">plethora of HTTP Status Codes</a>&nbsp;to choose from, however this list should be a good starting point:</p><ul><li><strong>200</strong>&nbsp;OK – [GET]<ul><li>The Consumer requested data from the Server, and the Server found it for them (Idempotent)</li></ul></li><li><strong>201</strong>&nbsp;CREATED – [POST/PUT/PATCH]<ul><li>The Consumer gave the Server data, and the Server created a resource</li></ul></li><li><strong>204</strong>&nbsp;NO CONTENT – [DELETE]<ul><li>The Consumer asked the Server to delete a Resource, and the Server deleted it</li></ul></li><li><strong>400</strong>&nbsp;INVALID REQUEST – [POST/PUT/PATCH]<ul><li>The Consumer gave bad data to the Server, and the Server did nothing with it (Idempotent)</li></ul></li><li><strong>404</strong>&nbsp;NOT FOUND – [*]<ul><li>The Consumer referenced an inexistant Resource or Collection, and the Server did nothing&nbsp;(Idempotent)</li></ul></li><li><strong>500</strong>&nbsp;INTERNAL SERVER ERROR – [*]<ul><li>The Server encountered an error, and the Consumer has no knowledge if the request was successful</li></ul></li></ul><h4 id="status-code-ranges">Status Code Ranges</h4><p>The&nbsp;<strong>1xx</strong>&nbsp;range is reserved for low-level HTTP stuff, and you’ll very likely go your entire career without manually sending one of these status codes.</p><p>The&nbsp;<strong>2xx</strong>&nbsp;range is reserved for successful messages where all goes as planned. Do your best to ensure your Server sends as many of these to the Consumer as possible.</p><p>The&nbsp;<strong>3xx</strong>&nbsp;range is reserved for traffic redirection. Most APIs do not use these requests much (not nearly as often as the SEO folks use them ;), however, the newer Hypermedia style APIs will make more use of these.</p><p>The&nbsp;<strong>4xx</strong>&nbsp;range is reserved for responding to errors made by the Consumer, e.g. they’re providing bad data or asking for things which don’t exist. These requests should be be&nbsp;idempotent, and not change the state of the server.</p><p>The&nbsp;<strong>5xx</strong>&nbsp;range is reserved as a response when the Server makes a mistake. Often times, these errors are thrown by low-level functions even outside of the developers hands, to ensure a Consumer gets some sort of response. The Consumer can’t possibly know the state of the server when a 5xx response is received, and so these should be avoidable.</p><h3 id="expected-return-documents">Expected Return Documents</h3><p>When performing actions using the different HTTP verbs to Server endpoints, a Consumer needs to get some sort of information in return. This list is pretty typical of RESTful APIs:</p><ul><li>GET /collection: Return a listing (array) of Resource objects</li><li>GET /collection/resource: Return an individual Resource object</li><li>POST /collection: Return the newly created Resource object</li><li>PUT /collection/resource: Return the complete Resource object</li><li>PATCH /collection/resource: Return the complete Resource object</li><li>DELETE /collection/resource: Return an empty document</li></ul><p>Note that when a Consumer creates a Resource, they usually do not know the ID of the Resource being created (nor other attributes such as created and modified timestamps, if applicable). These additional attributes are returned with subsequent request, and of course as a response to the initial POST.</p><h3 id="authentication">Authentication</h3><p>Most of the time a Server will want to know exactly who is making which Requests. Sure, some APIs provide endpoints to be consumed by the general (anonymous) public, but most of the time work is being perform on behalf of someone.</p><p><a href="https://tools.ietf.org/html/rfc6749" target="_blank" rel="noopener">OAuth 2.0</a>&nbsp;provides a great way of doing this. With each Request, you can be sure you know which Consumer is making requests, which User they are making requests on behalf of, and provides a (mostly) standardized way of expiring access or allowing Users to revoke access from a Consumer, all without the need for a third-party consumer to know the Users login credentials.</p><p>There are also&nbsp;<a href="http://tools.ietf.org/html/rfc5849" target="_blank" rel="noopener">OAuth 1.0</a>&nbsp;and&nbsp;<a href="https://dev.twitter.com/docs/oauth/xauth" target="_blank" rel="noopener">xAuth</a>, which fill the same space. Whichever method you choose, make sure it is something common and well documented with many different libraries written for the languages/platforms which your Consumers will likely be using.</p><p>I can honestly tell you that OAuth 1.0a, while it is the most secure of the options, is a huge pain in the ass to implement. I was surprised by the number of Third Party Developers who had to implement their own library since one didn’t exist for their language already. I’ve spent enough hours debugging cryptic “invalid signature” errors to recommend you choose an alternative.</p><h3 id="content-type">Content Type</h3><p>Currently, the most “exciting” of APIs provide JSON data from RESTful interfaces. This includes Facebook, Twitter, GitHub, you name it. XML appears to have lost the war a while ago (except in large corporate environments). SOAP, thankfully, is all but dead, and we really don’t see much APIs providing HTML to be consumed (unless, that is, you’re building a scraper!)</p><p>Developers using popular languages and frameworks can very likely parse any valid data format you return to them. You can even provide data in any of the aforementioned data formats (not including SOAP) quite easily, if you’re building a common response object and using a different serializer. What does matter though, is that you make use of the Accept header when responding with data.</p><p>Some API creators recommend adding a .json, .xml, or .html file extension to the URL (after the endpoint) for specifying the content type to be returned, although I’m personally not a fan of this. I really like the Accept header (which is built into the HTTP spec) and feel that is the appropriate thing to use.</p><h3 id="hypermedia-apis">Hypermedia APIs</h3><p>Hypermedia APIs are very likely the future of RESTful API design. They’re actually a pretty amazing concept, going “back to the roots” of how HTTP and HTML was intended to work.</p><p>When working with non-Hypermedia RESTful APIs, the URL Endpoints are part of the contract between the Server and the Consumer. These Endpoints MUST be known by the Consumer ahead of time, and changing them means the Consumer is no longer able to communicate with the Server as intended. This, as you can assume, is quite a limitation.</p><p>Now, API Consumers are of course not the only user agent making HTTP requests on the Internet. Far from it. Humans, with their web browsers, are the most common user agent making HTTP requests. Humans, however, are NOT locked into this predefined Endpoint URL contract that RESTful APIs are.&nbsp;What makes humans so special? Well, they’re able to read content, click links for headings which look interesting, and in general explore a website and interpret content to get to where they want to go. If a URL changes, a human is not affected (unless, that is, they bookmarked a page, in which case they go to the homepage and find a new route to their beloved data).</p><p>The Hypermedia API concept works the same way a human would. Requesting the Root of the API returns a listing of URLs which point perhaps to each collection of information, and describing each collection in a way which the Consumer can understand. Providing IDs for each resource isn’t important (or necessarily required), as long as a URL is provided.</p><p>With the Consumer of a Hypermedia API crawling links and gathering information, URLs are always up-to-date within responses, and do not need to be known beforehand as part of a contract. If a URL is ever cached, and a subsequent request returns a 404, the Consumer can simply go back to the root and discover the content again.</p><p>When retrieving a list of Resources within a Collection, an attribute containing a complete URL for the individual Resources are returned. When performing a POST/PATCH/PUT, the response can be a 3xx redirect to the complete Resource.</p><p>JSON doesn’t quite give us the semantics we need for specifying which attributes are URLs, nor how URLs relate to the current document. HTML, as you can probably guess, does provide this information. We may very well see our APIs coming full circle and returning back to consuming HTML. Considering how far we’ve come with CSS, one day we may even see &nbsp;it be common practice for APIs and Websites to use the exact same URLs and content.</p><h3 id="documentation">Documentation</h3><p>Honestly, if you don’t conform 100% to the criteria in this guide, your API will not necessarily be horrible. However, if you don’t properly document your API, nobody is going to know how to use it, and it WILL be a horrible API.</p><p>Make your Documentation available to unauthenticated developers.</p><p>Do not use automatic documentation generators, or if you do, at least make sure you’re doctoring it up and making it presentable.</p><p>Do not truncate example request and response bodies; show the whole thing. Use a syntax highlighter in your documentation.</p><p>Document expected response codes and possible error messages for each endpoint, and what could have gone wrong to cause those error messages.</p><p>If you’ve got the spare time, build a developer API console so that developers can immediately experiment with your API. It’s not as hard as you might think and developers (both internal and third party) will love you for it!</p><p>Make sure your documentation can be printed; CSS is a powerful thing; don’t be afraid to hide that sidebar when the docs are printed. Even if nobody ever prints a physical copy, you’d be surprised at how many developers like to print to PDF for offline reading.</p><h3 id="errata-raw-http-packet">Errata: Raw HTTP Packet</h3><p>Since everything we do is over HTTP, I’m going to show you a dissection of an HTTP packet. I’m often surprised at how many people don’t know what these things look like! When the Consumer sends a Request to the Server, they provide a set of Key/Value pairs, called a Header, along with two newline characters, and finally the request body. This is all sent in the same packet.</p><p>The server then responds in the say Key/Value pair format, with two newlines and then the response body. HTTP is very much a request/response protocol; there is no “Push” support (the Server sending data to the Consumer unprovoked), unless you use a different protocol such as Websockets.</p><p>When designing your API, you should be able to work with tools which allow you to look at raw HTTP packets. Consider using&nbsp;<a href="https://www.wireshark.org/" target="_blank" rel="noopener">Wireshark</a>, for example. Also, make sure you are using a framework / web server which allows you to read and change as many of these fields as possible.</p><h4 id="example-http-request">Example HTTP Request</h4><pre><code>POST /v1/animal HTTP/1.1Host: api.example.orgAccept: application/jsonContent-Type: application/jsonContent-Length: 24<p>{<br>  “name”: “Gir”,<br>  “animal_type”: 12<br>}</code></pre><h4 id="example-http-response">Example HTTP Response</h4><pre><code>HTTP/1.1 200 OK<br>Date: Wed, 18 Dec 2013 06:08:22 GMT<br>Content-Type: application/json<br>Access-Control-Max-Age: 1728000<br>Cache-Control: no-cache</p><p>{<br>  "id": 12,<br>  "created": 1386363036,<br>  "modified": 1386363036,<br>  "name": "Gir",<br>  "animal_type": 12<br>}</code></pre></p>]]></content>
      
      
      <categories>
          
          <category> RESTful </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RESTful </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WINDOWS 开源 ASP.NET CORE</title>
      <link href="/2020/02/02/WINDOWS%20%E5%BC%80%E6%BA%90%20ASP.NET%20CORE/"/>
      <url>/2020/02/02/WINDOWS%20%E5%BC%80%E6%BA%90%20ASP.NET%20CORE/</url>
      
        <content type="html"><![CDATA[<h1 id="net-core-guide">.NET Core Guide</h1><p><a href="https://docs.microsoft.com/en-us/dotnet/core/about" target="_blank" rel="noopener">.NET Core</a>&nbsp;is an&nbsp;<a href="https://github.com/dotnet/coreclr/blob/master/LICENSE.TXT" target="_blank" rel="noopener">open-source</a>&nbsp;general-purpose development platform maintained by Microsoft and the .NET community on&nbsp;<a href="https://github.com/dotnet/core" target="_blank" rel="noopener">GitHub</a>. It’s cross-platform, supporting Windows, macOS and Linux, and can be used in device, cloud, and IoT applications.</p><p>See&nbsp;<a href="https://docs.microsoft.com/en-us/dotnet/core/about" target="_blank" rel="noopener">About .NET Core</a>&nbsp;to learn more about .NET Core, including its characteristics, supported languages and frameworks, and key APIs.</p><p>Check out&nbsp;<a href="https://docs.microsoft.com/en-us/dotnet/core/tutorials/index" target="_blank" rel="noopener">.NET Core Tutorials</a>&nbsp;to learn how to create a simple .NET Core application. It only takes a few minutes to get your first app up and running. If you want to try .NET Core in you browser, look at the&nbsp;<a href="https://docs.microsoft.com/dotnet/csharp/quick-starts/hello-world" target="_blank" rel="noopener">Numbers in C#</a>&nbsp;quickstart.</p><p><span id="more-150"></span></p><h2 id="download-net-core-21">Download .NET Core 2.1</h2><p>Download the&nbsp;<a href="https://www.microsoft.com/net/download" target="_blank" rel="noopener">.NET Core 2.1 SDK</a>&nbsp;to try .NET Core on your Windows, macOS, or Linux machine. Visit&nbsp;<a href="https://hub.docker.com/r/microsoft/dotnet/" target="_blank" rel="noopener">microsoft/dotnet</a>&nbsp;if you prefer to use Docker containers.</p><p>All .NET Core versions are available at&nbsp;<a href="https://www.microsoft.com/net/download/archives" target="_blank" rel="noopener">.NET Core Downloads</a>&nbsp;if you’re looking for another .NET Core version.</p><h2 id="net-core-21">.NET Core 2.1</h2><p>The latest version is&nbsp;<a href="https://docs.microsoft.com/en-us/dotnet/core/whats-new/dotnet-core-2-1" target="_blank" rel="noopener">.NET Core 2.1</a>. New features include: global tools, high-performance APIs (such as&nbsp;<a href="https://docs.microsoft.com/en-us/dotnet/api/system.span-1" target="_blank" rel="noopener">System.Span&lt;T&gt;</a>), tiered JIT compilation,&nbsp;<a href="https://blogs.msdn.microsoft.com/dotnet/2018/05/30/announcing-net-core-2-1/" target="_blank" rel="noopener">build</a>&nbsp;and&nbsp;<a href="https://blogs.msdn.microsoft.com/dotnet/2018/04/18/performance-improvements-in-net-core-2-1/" target="_blank" rel="noopener">runtime performance improvements</a>, and support for Alpine and ARM32.</p><h2 id="create-your-first-application">Create your first application</h2><p>After installing the .NET Core SDK, open a command prompt. Type the following&nbsp;<code>dotnet</code>commands to create and run a C# application.</p><div>console</div><pre><code>dotnet new consoledotnet run</code></pre><p>You should see the following output:</p><div>console</div><pre><code>Hello World!</code></pre><h2 id="support">Support</h2><p>.NET Core is&nbsp;<a href="https://www.microsoft.com/net/support/policy" target="_blank" rel="noopener">supported by Microsoft</a>, on Windows, macOS and Linux. It’s updated for security and quality several times a year, typically monthly.</p><p>.NET Core binary distributions are built and tested on Microsoft-maintained servers in Azure and supported just like any Microsoft product.</p><p><a href="http://redhatloves.net/" target="_blank" rel="noopener">Red Hat supports .NET Core</a>&nbsp;on Red Hat Enterprise Linux (RHEL). Red Hat builds .NET Core from source and makes it available in the&nbsp;<a href="https://developers.redhat.com/products/softwarecollections/overview/" target="_blank" rel="noopener">Red Hat Software Collections</a>. Red Hat and Microsoft collaborate to ensure that .NET Core works well on RHEL.</p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go map详细使用方法</title>
      <link href="/2020/02/02/go%20map%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2020/02/02/go%20map%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Plea现在基本上所有的编程语言都有自带的map，或者dict，主要提供一个快速的查找，插入，删除，具备与存储体量无关的O（1）的性能，并且支持key上面的唯一性，</p><div><p>比如java里的HashMap，python里的Dictionary，scala里的各种Map等等。</p><p>go也原生提供了一个类似的数据类型，就叫做map。首先它是个mutable的，也就是说，可以随时对其进行修改。其次，它不是线程安全的。所以等价于java里的HashMap。</p></div><p><span id="more-197"></span></p><div><h2>申明和初始化</h2><pre><code>map[KeyType]ValueType</code></pre><p>这里的KeyType代表map的key类型，一定要是 comparable 的，而ValueType可以是任意的类型，甚至包括其他的内嵌的map<br>比如</p><pre><code>var m map[string]int</code></pre><p>这里的keyType是string，valueType就是int</p><p>map在go里是属于reference type，也就是作为方法的型参或者返回类型的是时候，传递也是这个reference的地址。不是map的本体。其次，这个map在申明的时候是nil map，需要如果没有初始化，那么就是nil<br>对于这个nil的map，可以对其进行任意的取值，返回都是（nil，err），但是如果对其设置一个新的值，就会panic<br>A nil map behaves like an empty map when reading, but attempts to write to a nil map will cause a runtime panic; don’t do that</p><p>所以需要先初始化，方法1:</p><pre><code>m = make(map[string]int)</code></pre><p>方法二：</p><pre><code>var m map[string]int = map[string]int{"hunter":12,"tony":10}</code></pre><p>或者初始化一个空的map</p><pre><code>m = map[string]int{}</code></pre><h2>读取</h2><pre><code>i := m["route"]</code></pre><p>如果route存在，就返回那个值，如果不存在，返回0值，也就是说，根据这个value的类型，返回缺省值，比如string，就返回“”，int 就返回0</p><h2>删除</h2><pre><code>delete(m,"route")</code></pre><p>如果route存在，删除成功，否则什么都没有发生<br>因为读取在不存在key的时候返回0值，为了区分是否成功，可以采用如下手段</p><pre><code>i, ok := m["route"]</code></pre><h2>遍历</h2><pre><code>for key, value := range m {    fmt.Println("Key:", key, "Value:", value)}</code></pre><h2>稍微高级点的用法</h2><p>利用0值，因为当从map中读取一个不存在的key的时候，返回0值，有时候很麻烦，有时候也可以很巧妙的利用起来，参考原文英文中的例子</p><pre><code>type Node struct {    Next  *Node    Value interface{}}var first *Node<p>func main(){<br>visited := make(map[*Node]bool)<br>    for n := first; n != nil; n = n.Next {<br>        if visited[n] {<br>            fmt.Println(“cycle detected”)<br>            break<br>        }<br>        visited[n] = true<br>        fmt.Println(n.Value)<br>    }<br>}</p><p></code></pre><p>这是一个检测单向链表是否有环的比较笨的办法，原理就是利用map判断这个key为＊Node的值在map中是否出现过来确定是否有环。<br>这里的visited就是map，从这里我们可以看到，指针类型也是comparable的，所以可以作为keytype，其次，调用if语句中的visited［n］的时候，我们巧妙的利用了bool类型的0值就是false这个原理，来判断这个keytype是否已经出现。</p><p>还是原文中的例子：</p><pre><code>type Person struct {<br>        Name  string<br>        Likes []string<br>    }<br>    var people []*Person</p><pre><code>likes := make(map[string][]*Person)for _, p := range people {    for _, l := range p.Likes {        likes[l] = append(likes[l], p)    }}for _, p := range likes[&quot;cheese&quot;] {    fmt.Println(p.Name, &quot;likes cheese.&quot;)}</code></pre><p></code></pre><p>我们有一个自定义的struct，Person，里面存了人的名字和他／她的爱好，现在我们要写一个简单的小程序，把所有的people（人员）按照相同兴趣进行分类</p><p>我们这里的代码就是利用两个go里的特征，<br>1, range对于非nil的map，可以进行遍历，但是如果是nil的map（也就是没有初始化的map），默认按照空的map处理，也就是不运行for循环的逻辑代码<br>2, append支持非nil和nil 的map，都能进行成功的append。这样，就能简化代码</p><p>刚才提到map里的keytype必须是comparable的，go的文档里有明确的定义：<br>The language spec defines this precisely, but in short, comparable types are boolean, numeric, string, pointer, channel, and interface types, and structs or arrays that contain only those types.</p><p>Notably absent from the list are slices, maps, and functions;</p><p>these types cannot be compared using ==, and may not be used as map keys.</p><h2>线程安全（goroutine）</h2><p>前面提到go的map不是线程安全的，因此需要加锁，一般的方法是，定义一个embeded的struct，类似于子类</p><pre><code>var counter = struct{<br>    sync.RWMutex<br>    m map[string]int<br>}{m: make(map[string]int)}<br></code></pre><p>读的时候，调用读锁</p><pre><code>counter.RLock()<br>n := counter.m["some_key"]<br>counter.RUnlock()<br>fmt.Println("some_key:", n)<br></code></pre><p>写的时候，写锁</p><pre><code>counter.Lock()<br>counter.m["some_key"]++<br>counter.Unlock()<br></code></pre><p>＃ 读取顺序<br>go的map是hashmap，所以读取遍历的顺序是不保证的，如果业务需要保证key的遍历顺序，建议将key单独保存到一个slice里</p><pre><code>import "sort"</p><p>var m map[int]string<br>var keys []int<br>for k := range m {<br>    keys = append(keys, k)<br>}<br>sort.Ints(keys)<br>for _, k := range keys {<br>    fmt.Println("Key:", k, "Value:", m[k])<br>}</code></pre></div><p>链接：<a href="https://www.jianshu.com/p/ba7852fbcc80" target="_blank" rel="noopener">https://www.jianshu.com/p/ba7852fbcc80</a></p></p>]]></content>
      
      
      <categories>
          
          <category> GoLang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初学goLang搭建WEB服务</title>
      <link href="/2020/02/02/%E5%88%9D%E5%AD%A6goLang%E6%90%AD%E5%BB%BAWEB%E6%9C%8D%E5%8A%A1/"/>
      <url>/2020/02/02/%E5%88%9D%E5%AD%A6goLang%E6%90%AD%E5%BB%BAWEB%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<pre><code>package main<br>import (<br>    "fmt"<br>    "net/http"<br>    "strings"<br>    "log"<br>)<br>func sayhelloName(w http.ResponseWriter, r *http.Request) {<br>    r.ParseForm() //解析参数，默认是不会解析的<br>    fmt.Println(r.Form) //这些信息是输出到服务器端的打印信息<br>    fmt.Println("path", r.URL.Path)<br>    fmt.Println("scheme", r.URL.Scheme)<br>    fmt.Println(r.Form["url_long"])<br>    for k, v := range r.Form {<br>        fmt.Println("key:", k)<br>        fmt.Println("val:", strings.Join(v, ""))<br>    }<br>    fmt.Fprintf(w, "Hello!") //这个写入到w的是输出到客户端的<br>}<br>func main() {<br>    http.HandleFunc("/", sayhelloName) //设置访问的路由<br>    err := http.ListenAndServe(":9090", nil) //设置监听的端口<br>    if err != nil {<br>        log.Fatal("ListenAndServe: ", err);<br>    }<br>}</code></pre><p><br></p>]]></content>
      
      
      <categories>
          
          <category> GoLang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网页头部的声明应该是用 lang=”zh” 还是 lang=”zh-cn”？</title>
      <link href="/2020/02/02/%E7%BD%91%E9%A1%B5%E5%A4%B4%E9%83%A8%E7%9A%84%E5%A3%B0%E6%98%8E%E5%BA%94%E8%AF%A5%E6%98%AF%E7%94%A8%20lang=%E2%80%9Dzh%E2%80%9D%20%E8%BF%98%E6%98%AF%20lang=%E2%80%9Dzh-cn%E2%80%9D%EF%BC%9F/"/>
      <url>/2020/02/02/%E7%BD%91%E9%A1%B5%E5%A4%B4%E9%83%A8%E7%9A%84%E5%A3%B0%E6%98%8E%E5%BA%94%E8%AF%A5%E6%98%AF%E7%94%A8%20lang=%E2%80%9Dzh%E2%80%9D%20%E8%BF%98%E6%98%AF%20lang=%E2%80%9Dzh-cn%E2%80%9D%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>Ple“zh”是中文，代表的是宏语言（Macrolanguage），单独使用表示“中文”整体，可以是方言、文言文、简体、繁体等单独一种，也可以是任意组合的混合内容。“zh-CN”理论上表示的是“中文 (中国大陆)”，因为中国大陆的官方语言是“普通话 (简体)”，所以这个“zh”的局限性就体现出来了：比如“尋尋覓覓，冷冷清清，悽悽慘慘戚戚”，用“zh-CN”描述没法表达出“繁體”和“文言文”，但描述成“zh-TW”则成了“中文 (繁體, 台灣)”，虽然指明了“繁体”，但还是没能体现出“文言文”，同时还丢失了“中国大陆”。针对这种情况，按照 BCP 47 规范 (详见参考链接 2)，应该使用独立语种更精确地描述：</p><p><span id="more-178"></span></p><div><div><pre><code>cmn 普通话（官话、国语）wuu 吴语（江浙话、上海话）czh 徽语（徽州话、严州话、吴语-徽严片）hak 客家语yue 粤语（广东话）nan 闽南语（福建话、台语）cpx 莆仙话（莆田话、兴化语）cdo 闽东语mnp 闽北语zco 闽中语gan 赣语（江西话）hsn 湘语（湖南话）cjy 晋语（山西话、陕北话）</code></pre></div><p>语言文字标签书写顺序：</p><div><pre><code>language-extlang-script-region-variant-extension-privateuse语言文字种类-扩展语言文字种类-书写格式-国家和地区-变体-扩展-私有</code></pre></div><p>语言文字标签示例：</p><div><pre><code>language:fr 法语es 西班牙语<p>language-extlang:<br>zh-lzh 中文 (文言文)<br>sgn-csl 手语 (中国大陆)</p><p>language-script:<br>cmn-Hans 普通话 (简体)<br>yue-Hant 粤语 (繁体)</p><p>language-region:<br>zh-CN 中文 (简体, 中国大陆)<br>en-US 英语 (美国)</p><p>language-script-region：<br>cmn-Hans-CN 普通话 (简体, 中国大陆)<br>cmn-Hant-TW 普通话 (繁体, 台湾)</p><p>language-script-variant:<br>zh-Latn-pinyin 汉语拼音（例：nǐ，拉丁字母形式）<br>zh-Bopo-pinyin 注音拼音（例：ㄋ丨ˇ，罗马字形式，中国大陆 1958 年以前使用，台湾目前使用）</p><p>常见的一般有 language、language-script 和 language-region 三种。<br></code></pre></div><p>附注 1：</p><p>“cmn”“wuu”“yue”等 2005 年确定的 extlang 标记已于 2009 年提升为 language 标记，维基百科中“吴语”“粤语”等页面均已使用最新的标准写法，以下以“zh”开头的写法已被废弃并不再推荐使用 (详见参考链接 3)，请直接去掉“zh-”前缀并使用“cmn”“wuu”“yue”等代替即可：</p><div><pre><code>zh-Hans, zh-Hans-CN, zh-cmn, zh-cmn-Hans, zh-wuu, zh-yue, zh-gan....<br>类似还有 zh-Hans-HK、zh-Hans-MO、zh-Hans-TW、zh-Hant<br></code></pre></div><p>废弃可能原因：在语言学的分类上，中国语言学者多认为“吴语”“粤语”“闽语”等是“汉语”的方言，而西方学者多认为这些语言是一门和“普通话”同级关系的单独语种。</p><p>中国大陆常见划分：</p><div><pre><code>1. 汉藏语系<br>   1.1. 汉语族<br>        1.1.1. 汉语<br>   1.2. 藏缅语族<br>   1.3. 苗瑶语族<br>   1.4. 壮侗语族</p><p>“汉语族”仅包含“汉语”一门语言，“吴语”“客家语”“粤语”“闽语”等均归属于“汉语”的不同方言。<br></code></pre></div><p>西方常见划分：</p><div><pre><code>1. 汉藏语系<br>   1.1. 汉语族<br>        1.1.1. 普通话（官话、国语）<br>        1.1.2. 吴语（江浙话、上海话）<br>        1.1.3. 徽语（徽州话、严州话、吴语-徽严片）<br>        1.1.4. 客家语<br>        1.1.5. 粤语（广东话）<br>        1.1.6. 闽南语（福建话、台语）<br>        1.1.7. 莆仙话（莆田话、兴化语）<br>        1.1.8. 闽东语<br>        1.1.9. 闽北语<br>        1.1.10. 闽中语<br>        1.1.11. 赣语（江西话）<br>        1.1.12. 湘语（湖南话）<br>        1.1.13. 晋语（山西话、陕北话）<br>   1.2. 藏缅语族<br>   1.3. 苗瑶语族<br>   1.4. 壮侗语族</p><p>“汉语族”包含“普通话”“吴语”“徽语”“客家话”“粤语”等多种语言。<br></code></pre></div><p><b>重点来了！</b></p><p>以下两种写法均正确，后者描述更精准，但大部分程序和操作系统都只能识别前者，使用新标准可能会造成无法匹配浏览器用户定义字体、网页翻译、程序语言自动切换等功能，为了兼容性的考量，推荐使用前者：</p><div><pre><code>zh-CN 中文 (简体, 中国大陆)  对应 cmn-Hans-CN 普通话 (简体, 中国大陆)<br>zh-SG 中文 (简体, 新加坡)   对应 cmn-Hans-SG 普通话 (简体, 新加坡)<br>zh-HK 中文 (繁体, 香港)     对应 yue-Hant-HK 粤语 (繁体, 香港)<br>zh-MO 中文 (繁体, 澳门)     对应 yue-Hant-MO 粤语 (繁体, 澳门)<br>zh-TW 中文 (繁体, 台湾)     对应 cmn-Hant-TW 普通话 (繁体, 台湾)<br></code></pre></div><p>附注 2：</p><p>同是简体中文页面， 默认或书面语均标记为“cmn (普通话)”，全文使用地方方言表达时，使用相应语言文字标签标记，例：</p><div><pre><code>“你” “我们” 用 cmn-Hans 普通话 (简体)<br>“侬” “啊啦” 用 wuu-Hans 吴语 (简体)<br>“你” “我哋” 用 yue-Hans 粤语 (简体)<br></code></pre></div><p>一般情况不用 region 选项，但如果要针对特定地区特定用语的友好性，则应设置区域，例 ：</p><div><pre><code>“消息” “黄梨” “自行车” 用 cmn-Hans-SG 普通话 (简体, 新加坡)<br>“消息” “菠萝” “自行车” 用 cmn-Hans-CN 普通话 (简体, 中国大陆)<br>“消息” “菠蘿” “自行車” 用 cmn-Hant-CN 普通话 (繁体, 中国大陆)<br>“訊息” “菠蘿” “单车”   用 cmn-Hant-HK 普通话 (繁体, 香港)<br>“訊息” “鳳梨” “腳踏車” 用 cmn-Hant-TW 普通话 (繁体, 台湾)</p><p>“analyse” “color” “elevator” 用 en-US 英语 (美国)<br>“analyze” “colour” “lift”    用 en-GB 英语 (英国)</code></pre><p>原文链接：<a href="https://www.zhihu.com/question/20797118/answer/63480740" target="_blank" rel="noopener">https://www.zhihu.com/question/20797118/answer/63480740</a></p></div></div><p><br></p></p>]]></content>
      
      
      <categories>
          
          <category> Html </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 博客快速建立及部署</title>
      <link href="/2020/02/02/hello-world/"/>
      <url>/2020/02/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
